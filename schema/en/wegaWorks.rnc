default namespace = "http://www.music-encoding.org/ns/mei"
namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"
namespace ns1 = "http://www.w3.org/1999/xhtml"
namespace rng = "http://relaxng.org/ns/structure/1.0"
namespace s = "http://www.ascc.net/xml/schematron"
namespace sch = "http://purl.oclc.org/dsdl/schematron"
namespace tei = "http://www.tei-c.org/ns/1.0"
namespace teix = "http://www.tei-c.org/ns/Examples"
namespace xi = "http://www.w3.org/2001/XInclude"
namespace xlink = "http://www.w3.org/1999/xlink"

# Schema generated from ODD source 2020-12-17T21:13:08Z. .
# TEI Edition: Version 4.0.0
# TEI Edition Location: https://www.tei-c.org/Vault/P5//
#

# This work is licensed under a  Creative Commons
# Attribution 3.0 Unported License (CC BY 3.0) .

sch:ns [ prefix = "tei" uri = "http://www.tei-c.org/ns/1.0" ]
data.ACCIDENTAL.WRITTEN =
  
  ## Sharp.
  "s"
  | 
    ## Flat.
    "f"
  | 
    ## Double sharp (written as 2 sharps).
    "ss"
  | 
    ## Double sharp (written using croix).
    "x"
  | 
    ## Double flat.
    "ff"
  | 
    ## Triple sharp (written as a croix followed by a sharp).
    "xs"
  | 
    ## Triple sharp (written as a sharp followed by a croix).
    "sx"
  | 
    ## Triple sharp (written as 3 sharps).
    "ts"
  | 
    ## Triple flat.
    "tf"
  | 
    ## Natural.
    "n"
  | 
    ## Natural + flat; used to cancel preceding double flat.
    "nf"
  | 
    ## Natural + sharp; used to cancel preceding double sharp.
    "ns"
  | 
    ## Sharp note raised by quarter tone (sharp modified by arrow).
    "su"
  | 
    ## Sharp note lowered by quarter tone (sharp modified by arrow).
    "sd"
  | 
    ## Flat note raised by quarter tone (flat modified by arrow).
    "fu"
  | 
    ## Flat note lowered by quarter tone (flat modified by arrow).
    "fd"
  | 
    ## Natural note raised by quarter tone (natural modified by arrow).
    "nu"
  | 
    ## Natural note lowered by quarter tone (natural modified by arrow).
    "nd"
  | 
    ## 1/4-tone flat accidental.
    "1qf"
  | 
    ## 3/4-tone flat accidental.
    "3qf"
  | 
    ## 1/4-tone sharp accidental.
    "1qs"
  | 
    ## 3/4-tone sharp accidental.
    "3qs"
data.ARTICULATION =
  
  ## Accent (Unicode 1D17B).
  "acc"
  | 
    ## Staccato (Unicode 1D17C).
    "stacc"
  | 
    ## Tenuto (Unicode 1D17D).
    "ten"
  | 
    ## Staccatissimo (Unicode 1D17E).
    "stacciss"
  | 
    ## Marcato (Unicode 1D17F).
    "marc"
  | 
    ## Spiccato.
    "spicc"
  | 
    ## Main note followed by short slide to higher, indeterminate pitch (Unicode 1D185).
    "doit"
  | 
    ## Main note preceded by short slide from lower, indeterminate pitch (Unicode 1D186).
    "scoop"
  | 
    ## Main note preceded by long slide from lower, often indeterminate pitch; also known as "squeeze".
    "rip"
  | 
    ## Main note preceded by "slide" from higher, indeterminate pitch.
    "plop"
  | 
    ## Main note followed by short "slide" to lower, indeterminate pitch.
    "fall"
  | 
    ## Main note followed by long "slide" to lower, indeterminate pitch.
    "longfall"
  | 
    ## "lip slur" to lower pitch, then return to written pitch.
    "bend"
  | 
    ## Main note followed by quick upward rise, then descent in pitch (Unicode 1D187).
    "flip"
  | 
    ## (Unicode 1D188).
    "smear"
  | 
    ## Alternation between written pitch and next highest overtone (brass instruments) or note minor third higher (woodwinds).
    "shake"
  | 
    ## Down bow (Unicode 1D1AA).
    "dnbow"
  | 
    ## Up bow (Unicode 1D1AB).
    "upbow"
  | 
    ## Harmonic (Unicode 1D1AC).
    "harm"
  | 
    ## Snap pizzicato (Unicode 1D1AD).
    "snap"
  | 
    ## Fingernail (Unicode 1D1B3).
    "fingernail"
  | 
    ## Stop harp string from sounding (Unicode 1D1B4).
    "damp"
  | 
    ## Stop all harp strings from sounding (Unicode 1D1B5).
    "dampall"
  | 
    ## Full (as opposed to stopped) tone.
    "open"
  | 
    ## "muffled" tone.
    "stop"
  | 
    ## Double tongue (Unicode 1D18A).
    "dbltongue"
  | 
    ## Triple tongue (Unicode 1D18B).
    "trpltongue"
  | 
    ## Use heel (organ pedal).
    "heel"
  | 
    ## Use toe (organ pedal).
    "toe"
  | 
    ## Percussive effect on guitar string(s).
    "tap"
  | 
    ## Left-hand pizzicato.
    "lhpizz"
  | 
    ## Uninterpreted dot.
    "dot"
  | 
    ## Uninterpreted stroke.
    "stroke"
data.AUGMENTDOT = xsd:nonNegativeInteger { maxInclusive = "4" }
data.BARRENDITION =
  
  ## Dashed line (Unicode 1D104).
  "dashed"
  | 
    ## Dotted line.
    "dotted"
  | 
    ## (Unicode 1D101).
    "dbl"
  | 
    ## Double dashed line.
    "dbldashed"
  | 
    ## Double dotted line.
    "dbldotted"
  | 
    ## (Unicode 1D102).
    "end"
  | 
    ## Bar line not rendered.
    "invis"
  | 
    ## Repeat start (Unicode 1D106).
    "rptstart"
  | 
    ## Repeat start and end.
    "rptboth"
  | 
    ## Repeat end (Unicode 1D107).
    "rptend"
  | 
    ## (Unicode 1D100).
    "single"
data.BEAT = xsd:decimal { minInclusive = "0" }
data.BOOLEAN =
  
  ## True.
  "true"
  | 
    ## False.
    "false"
data.CERTAINTY =
  
  ## High certainty.
  "high"
  | 
    ## Medium certainty.
    "medium"
  | 
    ## Low certainty.
    "low"
  | 
    ## An unknown level of certainty.
    "unknown"
data.CLEFLINE = xsd:positiveInteger
data.CLEFSHAPE =
  
  ## G clef (Unicode 1D11E).
  "G"
  | 
    ## Double G clef.
    "GG"
  | 
    ## F clef (Unicode 1D122).
    "F"
  | 
    ## C clef (Unicode 1D121).
    "C"
  | 
    ## Drum clef (Unicode 1D125 or Unicode 1D126).
    "perc"
  | 
    ## Tablature "clef"; i.e. usually "TAB" rendered vertically.
    "TAB"
data.CONFIDENCE = xsd:decimal { minInclusive = "0" maxInclusive = "1" }
data.COLORNAMES =
  
  ## Hex: #f0f8ff / RGB: 240,248,255
  "aliceblue"
  | 
    ## Hex: #faebd7 / RGB: 250,235,215
    "antiquewhite"
  | 
    ## Hex: #00ffff / RGB: 0,255,255
    "aqua"
  | 
    ## Hex: #7fffd4 / RGB: 127,255,212
    "aquamarine"
  | 
    ## Hex: #f0ffff / RGB: 240,255,255
    "azure"
  | 
    ## Hex: #f5f5dc / RGB: 245,245,220
    "beige"
  | 
    ## Hex: #ffe4c4 / RGB: 255,228,196
    "bisque"
  | 
    ## Hex: #000000 / RGB: 0,0,0
    "black"
  | 
    ## Hex: #ffebcd / RGB: 255,235,205
    "blanchedalmond"
  | 
    ## Hex: #0000ff / RGB: 0,0,255
    "blue"
  | 
    ## Hex: #8a2be2 / RGB: 138,43,226
    "blueviolet"
  | 
    ## Hex: #a52a2a / RGB: 165,42,42
    "brown"
  | 
    ## Hex: #deb887 / RGB: 222,184,135
    "burlywood"
  | 
    ## Hex: #5f9ea0 / RGB: 95,158,160
    "cadetblue"
  | 
    ## Hex: #7fff00 / RGB: 127,255,0
    "chartreuse"
  | 
    ## Hex: #d2691e / RGB: 210,105,30
    "chocolate"
  | 
    ## Hex: #ff7f50 / RGB: 255,127,80
    "coral"
  | 
    ## Hex: #6495ed / RGB: 100,149,237
    "cornflowerblue"
  | 
    ## Hex: #fff8dc / RGB: 255,248,220
    "cornsilk"
  | 
    ## Hex: #dc143c / RGB: 220,20,60
    "crimson"
  | 
    ## Hex: #00ffff / RGB: 0,255,255
    "cyan"
  | 
    ## Hex: #00008b / RGB: 0,0,139
    "darkblue"
  | 
    ## Hex: #008b8b / RGB: 0,139,139
    "darkcyan"
  | 
    ## Hex: #b8860b / RGB: 184,134,11
    "darkgoldenrod"
  | 
    ## Hex: #a9a9a9 / RGB: 169,169,169
    "darkgray"
  | 
    ## Hex: #006400 / RGB: 0,100,0
    "darkgreen"
  | 
    ## Hex: #a9a9a9 / RGB: 169,169,169
    "darkgrey"
  | 
    ## Hex: #bdb76b / RGB: 189,183,107
    "darkkhaki"
  | 
    ## Hex: #8b008b / RGB: 139,0,139
    "darkmagenta"
  | 
    ## Hex: #556b2f / RGB: 85,107,47
    "darkolivegreen"
  | 
    ## Hex: #ff8c00 / RGB: 255,140,0
    "darkorange"
  | 
    ## Hex: #9932cc / RGB: 153,50,204
    "darkorchid"
  | 
    ## Hex: #8b0000 / RGB: 139,0,0
    "darkred"
  | 
    ## Hex: #e9967a / RGB: 233,150,122
    "darksalmon"
  | 
    ## Hex: #8fbc8f / RGB: 143,188,143
    "darkseagreen"
  | 
    ## Hex: #483d8b / RGB: 72,61,139
    "darkslateblue"
  | 
    ## Hex: #2f4f4f / RGB: 47,79,79
    "darkslategray"
  | 
    ## Hex: #2f4f4f / RGB: 47,79,79
    "darkslategrey"
  | 
    ## Hex: #00ced1 / RGB: 0,206,209
    "darkturquoise"
  | 
    ## Hex: #9400d3 / RGB: 148,0,211
    "darkviolet"
  | 
    ## Hex: #ff1493 / RGB: 255,20,147
    "deeppink"
  | 
    ## Hex: #00bfff / RGB: 0,191,255
    "deepskyblue"
  | 
    ## Hex: #696969 / RGB: 105,105,105
    "dimgray"
  | 
    ## Hex: #696969 / RGB: 105,105,105
    "dimgrey"
  | 
    ## Hex: #1e90ff / RGB: 30,144,255
    "dodgerblue"
  | 
    ## Hex: #b22222 / RGB: 178,34,34
    "firebrick"
  | 
    ## Hex: #fffaf0 / RGB: 255,250,240
    "floralwhite"
  | 
    ## Hex: #228b22 / RGB: 34,139,34
    "forestgreen"
  | 
    ## Hex: #ff00ff / RGB: 255,0,255
    "fuchsia"
  | 
    ## Hex: #dcdcdc / RGB: 220,220,220
    "gainsboro"
  | 
    ## Hex: #f8f8ff / RGB: 248,248,255
    "ghostwhite"
  | 
    ## Hex: #ffd700 / RGB: 255,215,0
    "gold"
  | 
    ## Hex: #daa520 / RGB: 218,165,32
    "goldenrod"
  | 
    ## Hex: #808080 / RGB: 128,128,128
    "gray"
  | 
    ## Hex: #008000 / RGB: 0,128,0
    "green"
  | 
    ## Hex: #adff2f / RGB: 173,255,47
    "greenyellow"
  | 
    ## Hex: #808080 / RGB: 128,128,128
    "grey"
  | 
    ## Hex: #f0fff0 / RGB: 240,255,240
    "honeydew"
  | 
    ## Hex: #ff69b4 / RGB: 255,105,180
    "hotpink"
  | 
    ## Hex: #cd5c5c / RGB: 205,92,92
    "indianred"
  | 
    ## Hex: #4b0082 / RGB: 75,0,130
    "indigo"
  | 
    ## Hex: #fffff0 / RGB: 255,255,240
    "ivory"
  | 
    ## Hex: #f0e68c / RGB: 240,230,140
    "khaki"
  | 
    ## Hex: #e6e6fa / RGB: 230,230,250
    "lavender"
  | 
    ## Hex: #fff0f5 / RGB: 255,240,245
    "lavenderblush"
  | 
    ## Hex: #7cfc00 / RGB: 124,252,0
    "lawngreen"
  | 
    ## Hex: #fffacd / RGB: 255,250,205
    "lemonchiffon"
  | 
    ## Hex: #add8e6 / RGB: 173,216,230
    "lightblue"
  | 
    ## Hex: #f08080 / RGB: 240,128,128
    "lightcoral"
  | 
    ## Hex: #e0ffff / RGB: 224,255,255
    "lightcyan"
  | 
    ## Hex: #fafad2 / RGB: 250,250,210
    "lightgoldenrodyellow"
  | 
    ## Hex: #d3d3d3 / RGB: 211,211,211
    "lightgray"
  | 
    ## Hex: #90ee90 / RGB: 144,238,144
    "lightgreen"
  | 
    ## Hex: #d3d3d3 / RGB: 211,211,211
    "lightgrey"
  | 
    ## Hex: #ffb6c1 / RGB: 255,182,193
    "lightpink"
  | 
    ## Hex: #ffa07a / RGB: 255,160,122
    "lightsalmon"
  | 
    ## Hex: #20b2aa / RGB: 32,178,170
    "lightseagreen"
  | 
    ## Hex: #87cefa / RGB: 135,206,250
    "lightskyblue"
  | 
    ## Hex: #778899 / RGB: 119,136,153
    "lightslategray"
  | 
    ## Hex: #778899 / RGB: 119,136,153
    "lightslategrey"
  | 
    ## Hex: #b0c4de / RGB: 176,196,222
    "lightsteelblue"
  | 
    ## Hex: #ffffe0 / RGB: 255,255,224
    "lightyellow"
  | 
    ## Hex: #00ff00 / RGB: 0,255,0
    "lime"
  | 
    ## Hex: #32cd32 / RGB: 50,205,50
    "limegreen"
  | 
    ## Hex: #faf0e6 / RGB: 250,240,230
    "linen"
  | 
    ## Hex: #ff00ff / RGB: 255,0,255
    "magenta"
  | 
    ## Hex: #800000 / RGB: 128,0,0
    "maroon"
  | 
    ## Hex: #66cdaa / RGB: 102,205,170
    "mediumaquamarine"
  | 
    ## Hex: #0000cd / RGB: 0,0,205
    "mediumblue"
  | 
    ## Hex: #ba55d3 / RGB: 186,85,211
    "mediumorchid"
  | 
    ## Hex: #9370db / RGB: 147,112,219
    "mediumpurple"
  | 
    ## Hex: #3cb371 / RGB: 60,179,113
    "mediumseagreen"
  | 
    ## Hex: #7b68ee / RGB: 123,104,238
    "mediumslateblue"
  | 
    ## Hex: #00fa9a / RGB: 0,250,154
    "mediumspringgreen"
  | 
    ## Hex: #48d1cc / RGB: 72,209,204
    "mediumturquoise"
  | 
    ## Hex: #c71585 / RGB: 199,21,133
    "mediumvioletred"
  | 
    ## Hex: #191970 / RGB: 25,25,112
    "midnightblue"
  | 
    ## Hex: #f5fffa / RGB: 245,255,250
    "mintcream"
  | 
    ## Hex: #ffe4e1 / RGB: 255,228,225
    "mistyrose"
  | 
    ## Hex: #ffe4b5 / RGB: 255,228,181
    "moccasin"
  | 
    ## Hex: #ffdead / RGB: 255,222,173
    "navajowhite"
  | 
    ## Hex: #000080 / RGB: 0,0,128
    "navy"
  | 
    ## Hex: #fdf5e6 / RGB: 253,245,230
    "oldlace"
  | 
    ## Hex: #808000 / RGB: 128,128,0
    "olive"
  | 
    ## Hex: #6b8e23 / RGB: 107,142,35
    "olivedrab"
  | 
    ## Hex: #ffa500 / RGB: 255,165,0
    "orange"
  | 
    ## Hex: #ff4500 / RGB: 255,69,0
    "orangered"
  | 
    ## Hex: #da70d6 / RGB: 218,112,214
    "orchid"
  | 
    ## Hex: #eee8aa / RGB: 238,232,170
    "palegoldenrod"
  | 
    ## Hex: #98fb98 / RGB: 152,251,152
    "palegreen"
  | 
    ## Hex: #afeeee / RGB: 175,238,238
    "paleturquoise"
  | 
    ## Hex: #db7093 / RGB: 219,112,147
    "palevioletred"
  | 
    ## Hex: #ffefd5 / RGB: 255,239,213
    "papayawhip"
  | 
    ## Hex: #ffdab9 / RGB: 255,218,185
    "peachpuff"
  | 
    ## Hex: #cd853f / RGB: 205,133,63
    "peru"
  | 
    ## Hex: #ffc0cb / RGB: 255,192,203
    "pink"
  | 
    ## Hex: #dda0dd / RGB: 221,160,221
    "plum"
  | 
    ## Hex: #b0e0e6 / RGB: 176,224,230
    "powderblue"
  | 
    ## Hex: #800080 / RGB: 128,0,128
    "purple"
  | 
    ## Hex: #ff0000 / RGB: 255,0,0
    "red"
  | 
    ## Hex: #bc8f8f / RGB: 188,143,143
    "rosybrown"
  | 
    ## Hex: #4169e1 / RGB: 65,105,225
    "royalblue"
  | 
    ## Hex: #8b4513 / RGB: 139,69,19
    "saddlebrown"
  | 
    ## Hex: #fa8072 / RGB: 250,128,114
    "salmon"
  | 
    ## Hex: #f4a460 / RGB: 244,164,96
    "sandybrown"
  | 
    ## Hex: #2e8b57 / RGB: 46,139,87
    "seagreen"
  | 
    ## Hex: #fff5ee / RGB: 255,245,238
    "seashell"
  | 
    ## Hex: #a0522d / RGB: 160,82,45
    "sienna"
  | 
    ## Hex: #c0c0c0 / RGB: 192,192,192
    "silver"
  | 
    ## Hex: #87ceeb / RGB: 135,206,235
    "skyblue"
  | 
    ## Hex: #6a5acd / RGB: 106,90,205
    "slateblue"
  | 
    ## Hex: #708090 / RGB: 112,128,144
    "slategray"
  | 
    ## Hex: #708090 / RGB: 112,128,144
    "slategrey"
  | 
    ## Hex: #fffafa / RGB: 255,250,250
    "snow"
  | 
    ## Hex: #00ff7f / RGB: 0,255,127
    "springgreen"
  | 
    ## Hex: #4682b4 / RGB: 70,130,180
    "steelblue"
  | 
    ## Hex: #d2b48c / RGB: 210,180,140
    "tan"
  | 
    ## Hex: #008080 / RGB: 0,128,128
    "teal"
  | 
    ## Hex: #d8bfd8 / RGB: 216,191,216
    "thistle"
  | 
    ## Hex: #ff6347 / RGB: 255,99,71
    "tomato"
  | 
    ## Hex: #40e0d0 / RGB: 64,224,208
    "turquoise"
  | 
    ## Hex: #ee82ee / RGB: 238,130,238
    "violet"
  | 
    ## Hex: #f5deb3 / RGB: 245,222,179
    "wheat"
  | 
    ## Hex: #ffffff / RGB: 255,255,255
    "white"
  | 
    ## Hex: #f5f5f5 / RGB: 245,245,245
    "whitesmoke"
  | 
    ## Hex: #ffff00 / RGB: 255,255,0
    "yellow"
  | 
    ## Hex: #9acd32 / RGB: 154,205,50
    "yellowgreen"
data.COLORVALUES =
  xsd:token { pattern = "#[0-9A-Fa-f]{6,6}" }
  | xsd:token { pattern = "#[0-9A-Fa-f]{8,8}" }
  | xsd:token {
      pattern =
        "rgb\((\s*(([01]?[0-9]?[0-9])|2[0-4][0-9]|25[0-5])\s*,\s*){2}([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\s*\)"
    }
  | xsd:token {
      pattern =
        "rgba\(\s*(([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\s*,\s*){3}(0(\.\d+)?|1(\.0+)?)\s*\)|rgba\(\s*(((\d{1,2})?%|100%)\s*,\s*){2}(\d{1,2}%|100%)\s*,\s*(0(\.\d+)?|1(\.0+)?)\s*\)"
    }
  | xsd:token {
      pattern =
        "hsl\(\s*((\d{1,2})|[12]\d{2}|3[0-5]\d|360)\s*,\s*(\d{1,2}%|100%)\s*,\s*(\d{1,2}%|100%)\s*\)"
    }
  | xsd:token {
      pattern =
        "hsla\(\s*(\d{1,2}|[12]\d{2}|3[0-5]\d|360)\s*,\s*(\d{1,2}%|100%)\s*,\s*(\d{1,2}%|100%)\s*,\s*(0(\.\d+)?|1(\.0+)?)\s*\)"
    }
data.COLOR = data.COLORNAMES | data.COLORVALUES
data.DEGREES =
  xsd:decimal { maxInclusive = "360.0" minInclusive = "-360.0" }
data.DURATION = data.DURATION.cmn
data.FONTFAMILY = xsd:token
data.FONTNAME = xsd:token
data.FONTSIZE = data.FONTSIZENUMERIC | data.FONTSIZETERM | data.PERCENT
data.FONTSIZENUMERIC =
  xsd:token { pattern = "\d*(\.\d+)?(pt|vu)" }
  - ((xsd:token { pattern = "(pt|vu)" }
      | xsd:token { pattern = "0+(pt|vu)" }
      | xsd:token { pattern = "0+(\.0+)?(pt|vu)" }
      | xsd:token { pattern = "\.0+(pt|vu)" }))
data.FONTSIZETERM =
  
  ## Smaller than x-small.
  "xx-small"
  | 
    ## Smaller than small, larger than xx-small.
    "x-small"
  | 
    ## Smaller than normal, larger than x-small.
    "small"
  | 
    ## Smaller than large, larger than small.
    "normal"
  | 
    ## Smaller than x-large, larger than normal.
    "large"
  | 
    ## Smaller than xx-large, larger than large.
    "x-large"
  | 
    ## Larger than x-large.
    "xx-large"
  | 
    ## One size smaller than the current size.
    "smaller"
  | 
    ## One size larger than the current size.
    "larger"
data.FONTSTYLE =
  
  ## Text slants to right.
  "italic"
  | 
    ## Unadorned.
    "normal"
  | 
    ## Text slants to the left.
    "oblique"
data.FONTWEIGHT =
  
  ## Bold or heavy.
  "bold"
  | 
    ## Not bold.
    "normal"
data.GRACE =
  
  ## Time "stolen" from following note.
  "acc"
  | 
    ## Time "stolen" from previous note.
    "unacc"
  | 
    ## No interpretation regarding performed value of grace note.
    "unknown"
data.HORIZONTALALIGNMENT =
  
  ## Left aligned.
  "left"
  | 
    ## Right aligned.
    "right"
  | 
    ## Centered.
    "center"
  | 
    ## Left and right aligned.
    "justify"
data.ISODATE = wega.data.temporal.iso
data.KEYFIFTHS = xsd:token { pattern = "mixed|0|([1-9]|1[0-2])[f|s]" }
data.MEASUREBEAT =
  xsd:token { pattern = "([0-9]+m\s*\+\s*)?[0-9]+(\.?[0-9]*)?" }
data.MEASUREBEATOFFSET =
  xsd:token { pattern = "(\+|-)?[0-9]+m\+[0-9]+(\.[0-9]*)?" }
data.METERSIGN =
  
  ## Common time; i.e. 4/4.
  "common"
  | 
    ## Cut time; i.e. 2/2.
    "cut"
data.MODSRELATIONSHIP =
  
  ## Temporal predecessor of the resource.
  "preceding"
  | 
    ## Temporal successor to the resource.
    "succeeding"
  | 
    ## Original form of the resource.
    "original"
  | 
    ## Parent containing the resource.
    "host"
  | 
    ## Intellectual or physical component of the resource.
    "constituent"
  | 
    ## Version of the resource's intellectual content not changed enough to be a different work.
    "otherVersion"
  | 
    ## Version of the resource in a different physical format.
    "otherFormat"
  | 
    ## Published bibliographic description, review, abstract, or index of the resource's content.
    "isReferencedBy"
  | 
    ## Cited or referred to in the resource.
    "references"
data.NMTOKEN = xsd:NMTOKEN
data.NONSTAFFPLACE =
  
  ## At the foot of the page.
  "botmar"
  | 
    ## At the top of the page.
    "topmar"
  | 
    ## At the left of the page.
    "leftmar"
  | 
    ## At the right of the page.
    "rightmar"
  | 
    ## On the opposite, i.e. facing, page.
    "facing"
  | 
    ## On the other side of the leaf.
    "overleaf"
  | 
    ## At the end of this division; e.g., chapter, volume, etc.
    "end"
  | 
    ## Within a line text; i.e., an insertion.
    "inter"
  | 
    ## Between the lines of text, less exact than "sub" or "super".
    "intra"
  | 
    ## Above a line of text, more exact than "intra(linear)". Do not confuse with superscript rendition.
    "super"
  | 
    ## Below a line of text, more exact than "intra(linear)". Do not confuse with subscript rendition.
    "sub"
  | 
    ## In a predefined space; i.e., that left by an earlier scribe.
    "inspace"
  | 
    ## Obscures original text; e.g., via overstrike, addition of new writing surface material, etc.
    "superimposed"
data.NOTATIONTYPE =
  
  ## Common Music Notation.
  "cmn"
  | 
    ## Mensural notation.
    "mensural"
  | 
    ## Black mensural notation.
    "mensural.black"
  | 
    ## White mensural notation.
    "mensural.white"
  | 
    ## Neumatic notation.
    "neume"
  | 
    ## Tablature notation.
    "tab"
data.OCTAVE = xsd:nonNegativeInteger { maxInclusive = "9" }
data.OCTAVE.DIS = xsd:positiveInteger { pattern = "8|15|22" }
data.OTHERSTAFF =
  
  ## The staff immediately above.
  "above"
  | 
    ## The staff immediately below.
    "below"
data.PERCENT = xsd:token { pattern = "[0-9]+(\.?[0-9]*)?%" }
data.PITCHNAME = xsd:token { pattern = "[a-g]" }
data.PLACEMENT = data.STAFFREL | data.NONSTAFFPLACE | data.NMTOKEN
data.RELATIONSHIP =
  data.FRBRRELATIONSHIP | data.MODSRELATIONSHIP | data.NMTOKEN
data.STAFFREL = data.STAFFREL.basic | data.STAFFREL.extended
data.STAFFREL.basic =
  
  ## Above the staff.
  "above"
  | 
    ## Below the staff.
    "below"
data.STAFFREL.extended =
  
  ## Between staves.
  "between"
  | 
    ## Within/on the staff.
    "within"
data.TEMPOVALUE = xsd:decimal
data.TEXTRENDITIONLIST =
  
  ## Surrounded by single quotes.
  "quote"
  | 
    ## Surrounded by double quotes.
    "quotedbl"
  | 
    ## Italicized (slanted to right).
    "italic"
  | 
    ## Oblique (slanted to left).
    "oblique"
  | 
    ## Small capitals.
    "smcaps"
  | 
    ## Relative font weight.
    "bold"
  | 
    ## Relative font weight.
    "bolder"
  | 
    ## Relative font weight.
    "lighter"
  | 
    ## Enclosed in box.
    "box"
  | 
    ## Enclosed in ellipse/circle.
    "circle"
  | 
    ## Enclosed in diamond.
    "dbox"
  | 
    ## Enclosed in triangle.
    "tbox"
  | 
    ## Struck through by '\' (back slash).
    "bslash"
  | 
    ## Struck through by '/' (forward slash).
    "fslash"
  | 
    ## Struck through by '-'; may be qualified to indicate multiple parallel lines, e.g. line-through(2).
    "line-through"
  | 
    ## Not rendered, invisible.
    "none"
  | 
    ## Line above the text; may be qualified to indicate multiple parallel lines, e.g. overline(3).
    "overline"
  | 
    ## Use for deleted text fully or partially obscured by other text (such as 'XXXXX') or musical symbols (such as notes, rests, etc.).
    "overstrike"
  | 
    ## Struck through by '-'; equivalent to line-through; may be qualified to indicate multiple parallel lines, e.g. strike(3).
    "strike"
  | 
    ## Subscript.
    "sub"
  | 
    ## Superscript.
    "sup"
  | 
    ## Use for added text or musical symbols that fully or partially obscure text from an earlier writing stage.
    "superimpose"
  | 
    ## Underlined; may be qualified to indicate multiple parallel lines, e.g. underline(2).
    "underline"
  | 
    ## Crossed-out; equivalent to 'bslash' (\) plus 'fslash' (/); that is, a hand-written 'X'; may be qualified to indicate multiple parallel lines, e.g. x-through(2).
    "x-through"
  | 
    ## Left-to-right (BIDI embed).
    "ltr"
  | 
    ## Right-to-left (BIDI embed).
    "rtl"
  | 
    ## Left-to-right (BIDI override).
    "lro"
  | 
    ## Right-to-left (BIDI override).
    "rlo"
data.TEXTRENDITIONPAR =
  xsd:string {
    pattern =
      "(underline|overline|line-through|strike|x-through)\(\d+\)"
  }
  | xsd:string {
      pattern = "(letter-spacing|line-height)\((\+|-)?\d+(\.\d+)?%?\)"
    }
data.TEXTRENDITION = data.TEXTRENDITIONLIST | data.TEXTRENDITIONPAR
data.URI = xsd:anyURI
data.VERTICALALIGNMENT =
  
  ## Top aligned.
  "top"
  | 
    ## Middle aligned.
    "middle"
  | 
    ## Bottom aligned.
    "bottom"
  | 
    ## Baseline aligned.
    "baseline"
data.WORD = xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})*" }
data.FRBRRELATIONSHIP =
  
  ## Target is an abridgement, condensation, or expurgation of the current entity.
  "hasAbridgement"
  | 
    ## Reciprocal relationship of hasAbridgement.
    "isAbridgementOf"
  | 
    ## Target is an adaptation, paraphrase, free translation, variation (music), harmonization (music), or fantasy (music) of the current entity.
    "hasAdaptation"
  | 
    ## Reciprocal relationship of hasAdaptation.
    "isAdaptationOf"
  | 
    ## Target is an alternate format or simultaneously released edition of the current entity.
    "hasAlternate"
  | 
    ## Reciprocal relationship of hasAlternate.
    "isAlternateOf"
  | 
    ## Target is an arrangement (music) of the current entity.
    "hasArrangement"
  | 
    ## Reciprocal relationship of hasArrangement.
    "isArrangementOf"
  | 
    ## Target is a cadenza, libretto, choreography, ending for unfinished work, incidental music, or musical setting of a text of the current entity.
    "hasComplement"
  | 
    ## Reciprocal relationship of hasComplement.
    "isComplementOf"
  | 
    ## Target is a physical embodiment of the current abstract entity; describes the expression-to-manifestation relationship.
    "hasEmbodiment"
  | 
    ## Reciprocal relationship of hasEmbodiment.
    "isEmbodimentOf"
  | 
    ## Target is an exemplar of the class of things represented by the current entity; describes the manifestation-to-item relationship.
    "hasExemplar"
  | 
    ## Reciprocal relationship of hasExamplar.
    "isExemplarOf"
  | 
    ## Target is a parody, imitation, or travesty of the current entity.
    "hasImitation"
  | 
    ## Reciprocal relationship of hasImitation.
    "isImitationOf"
  | 
    ## Target is a chapter, section, part, etc.; volume of a multivolume manifestation; volume/issue of serial; intellectual part of a multi-part work; illustration for a text; sound aspect of a film; soundtrack for a film on separate medium; soundtrack for a film embedded in film; monograph in a series; physical component of a particular copy; the binding of a book of the current entity.
    "hasPart"
  | 
    ## Reciprocal relationship of hasPart.
    "isPartOf"
  | 
    ## Target is a realization of the current entity; describes the work-to-expression relationship.
    "hasRealization"
  | 
    ## Reciprocal relationship of hasRealization.
    "isRealizationOf"
  | 
    ## Target has been reconfigured: bound with, split into, extracted from the current entity.
    "hasReconfiguration"
  | 
    ## Reciprocal relationship of hasReconfiguration.
    "isReconfigurationOf"
  | 
    ## Target is a reproduction, microreproduction, macroreproduction, reprint, photo-offset reprint, or facsimile of the current entity.
    "hasReproduction"
  | 
    ## Reciprocal relationship of hasReproduction.
    "isReproductionOf"
  | 
    ## Target is a revised edition, enlarged edition, or new state (graphic) of the current entity.
    "hasRevision"
  | 
    ## Reciprocal relationship of hasRevision.
    "isRevisionOf"
  | 
    ## Target is a sequel or succeeding work of the current entity.
    "hasSuccessor"
  | 
    ## Reciprocal relationship of hasSuccessor.
    "isSuccessorOf"
  | 
    ## Target is a digest or abstract of the current entity.
    "hasSummarization"
  | 
    ## Reciprocal relationship of hasSummarization.
    "isSummarizationOf"
  | 
    ## Target is an index, concordance, teacher's guide, gloss, supplement, or appendix of the current entity.
    "hasSupplement"
  | 
    ## Reciprocal relationship of hasSupplement.
    "isSupplementOf"
  | 
    ## Target is a dramatization, novelization, versification, or screenplay of the current entity.
    "hasTransformation"
  | 
    ## Reciprocal relationship of hasTransformation.
    "isTransformationOf"
  | 
    ## Target is a literal translation or transcription (music) of the current entity.
    "hasTranslation"
  | 
    ## Reciprocal relationship of hasTranslation.
    "isTranslationOf"
macro.musicPart = model.frontLike?, (body | group)?, model.backLike?
macro.struc-unstrucContent =
  (model.headLike*, model.pLike*)
  | (text | model.textPhraseLike.limited)*
macro.availabilityPart =
  (model.headLike*,
   (price
    | useRestrict
    | model.addressLike
    | model.dateLike
    | model.identifierLike)*)
  | text
macro.bibldescPart =
  editionStmt?, pubStmt?, physDesc*, physLoc*, seriesStmt*
data.DURATION.cmn =
  
  ## Quadruple whole note.
  "long"
  | 
    ## Double whole note.
    "breve"
  | 
    ## Whole note.
    "1"
  | 
    ## Half note.
    "2"
  | 
    ## Quarter note.
    "4"
  | 
    ## 8th note.
    "8"
  | 
    ## 16th note.
    "16"
  | 
    ## 32nd note.
    "32"
  | 
    ## 64th note.
    "64"
  | 
    ## 128th note.
    "128"
  | 
    ## 256th note.
    "256"
  | 
    ## 512th note.
    "512"
  | 
    ## 1024th note.
    "1024"
  | 
    ## 2048th note.
    "2048"
key.person.pattern = xsd:string { pattern = "H00\d{4}" }
key.work.pattern = xsd:string { pattern = "H02\d{4}" }
marcRelator.list =
  
  ## (Actor) A performer contributing to an expression of a work by acting as a cast member or player in a musical or dramatic presentation, etc.
  "marc:act"
  | 
    ## (Arranger) A person, family, or organization contributing to a musical work by rewriting the composition for a medium of performance different from that for which the work was originally intended, or modifying the work for the same medium of performance, etc., such that the musical substance of the original composition remains essentially unchanged. For extensive modification that effectively results in the creation of a new musical work, see composer.
    "marc:arr"
  | 
    ## (Associated name) A person or organization associated with or found in an item or collection, which cannot be determined to be that of a Former owner [fmo] or other designated relationship indicative of provenance.
    "marc:asn"
  | 
    ## (Author) Use for a person or organization chiefly responsible for the intellectual or artistic content of a work, usually printed text. This term may also be used when more than one person or body bears such responsibility.
    "marc:aut"
  | 
    ## (Author of textual source) Use for a person responsible for the textual source of a work. This term may also be used when more than one person or body bears such responsibility.
    "marc:ats"
  | 
    ## (Collaborator)
    "marc:clb"
  | 
    ## (Composer) Use for a person or organization who creates a musical work, usually a piece of music in manuscript or printed form.
    "marc:cmp"
  | 
    ## (Creator) A person or organization responsible for the intellectual or artistic content of a resource
    "marc:cre"
  | 
    ## (Dedicatee) Use for a person or organization to whom a book, manuscript, etc., is dedicated (not the recipient of a gift).
    "marc:dte"
  | 
    ## (Engraver) A person or organization who cuts letters, figures, etc. on a surface, such as a wooden or metal plate used for printing.
    "marc:egr"
  | 
    ## (Former owner) A person, family, or organization formerly having legal possession of an item
    "marc:fmo"
  | 
    ## (Librettist) Use for a person or organization who is a writer of the text of an opera, oratorio, etc.
    "marc:lbt"
  | 
    ## (Editor) Use for a person or organization who prepares for publication a work not primarily his/her own, such as by elucidating text, adding introductory or other critical matter, or technically directing an editorial staff.
    "marc:edt"
  | 
    ## (Editorial Assistant) Use for a person who assisted in editing the text/score.
    "marc:editorial_assistant"
  | 
    ## (Lyricist) Use for a person or organization who is a writer of the text of a song.
    "marc:lyr"
  | 
    ## (Music copyist) A person who transcribes or copies musical notation.
    "marc:mcp"
  | 
    ## (Performer) A person contributing to a resource by performing music, acting, dancing, speaking, etc., often in a musical or dramatic presentation, etc. If specific codes are used, [prf] is used for a person whose principal skill is not known or specified
    "marc:prf"
  | 
    ## (Scribe) A person who is an amanuensis and for a writer of manuscripts proper.
    "marc:scr"
  | 
    ## (Translator) Use for a person or organization who renders a text from one language into another, or from an older form of a language into the modern form.
    "marc:trl"
wega.data.temporal.iso = xsd:date | xsd:gYear | xsd:gYearMonth
att.notationType.attributes =
  att.notationType.attribute.notationtype,
  att.notationType.attribute.notationsubtype
att.notationType.attribute.notationtype =
  
  ## Contains classification of the notation contained or described by the element bearing this attribute.
  attribute notationtype { data.NOTATIONTYPE }?
att.notationType.attribute.notationsubtype =
  
  ## Provides any sub-classification of the notation contained or described by the element, additional to that given by its notationtype attribute.
  attribute notationsubtype { xsd:NMTOKEN }?
sch:pattern [
  id =
    "wegaWorks-att.notationType-notationsubtype-When_notationsubtype-constraint-rule-5"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "mei:*[@notationsubtype]"
    "\x{a}" ~
    "              "
    sch:assert [
      test = "@notationtype"
      "An element with a notationsubtype attribute must have\x{a}" ~
      "                a notationtype attribute."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
model.expressionLike = expression
model.itemLike = item
model.manifestationLike = notAllowed
expression =
  
  ## Intellectual or artistic realization of a work.
  element expression {
    model.headLike*,
    model.identifierLike*,
    model.titleLike+,
    model.respLikePart*,
    model.workIdent*,
    creation?,
    history?,
    langUsage?,
    perfMedium?,
    extent*,
    contents?,
    notesStmt?,
    classification?,
    componentList?,
    relationList?,
    att.common.attributes,
    att.authorized.attributes,
    att.bibl.attributes,
    att.dataPointing.attributes,
    empty
  }
expressionList =
  
  ## Gathers bibliographic expression entities.
  element expressionList {
    model.headLike*, model.expressionLike*, att.common.attributes, empty
  }
item =
  
  ## Single instance or exemplar of a source/manifestation.
  element item {
    model.headLike*,
    model.identifierLike*,
    availability?,
    physDesc?,
    physLoc?,
    history?,
    notesStmt?,
    classification?,
    componentList?,
    relationList?,
    att.common.attributes,
    att.authorized.attributes,
    att.bibl.attributes,
    att.dataPointing.attributes,
    att.pointing.attributes,
    att.targetEval.attributes,
    empty
  }
itemList =
  
  ## Gathers bibliographic item entities.
  element itemList {
    model.headLike*, model.itemLike*, att.common.attributes, empty
  }
att.accid.log.attributes =
  att.accidental.attributes,
  att.controlEvent.attributes,
  att.accid.log.attribute.func
att.accid.log.attribute.func =
  
  ## Records the function of an accidental.
  attribute func {
    
    ## Cautionary accidental.
    "caution"
    | 
      ## Editorial accidental.
      "edit"
  }?
att.accidental.attributes = att.accidental.attribute.accid
att.accidental.attribute.accid =
  
  ## Captures a written accidental.
  attribute accid { data.ACCIDENTAL.WRITTEN }?
att.annot.log.attributes =
  att.duration.additive.attributes,
  att.layerIdent.attributes,
  att.partIdent.attributes,
  att.staffIdent.attributes,
  att.startEndId.attributes,
  att.timestamp.logical.attributes,
  att.timestamp2.logical.attributes
att.artic.log.attributes =
  att.articulation.attributes, att.controlEvent.attributes
att.articulation.attributes = att.articulation.attribute.artic
att.articulation.attribute.artic =
  [
    a:documentation [
      "Encodes the written articulation(s). Articulations are normally encoded in order from the note head outward; that is, away from the stem. See additional notes at att.vis.note. Only articulations should be encoded in the artic attribute; for example, fingerings should be encoded using the "
      ns1:code [ "<fing>" ]
      " element."
    ]
  ]
  attribute artic {
    list { data.ARTICULATION+ }
  }?
att.audience.attributes = att.audience.attribute.audience
att.audience.attribute.audience =
  
  ## The intended audience.
  attribute audience {
    
    ## Internal use only.
    "private"
    | 
      ## Available to all audiences.
      "public"
  }?
att.augmentDots.attributes = att.augmentDots.attribute.dots
att.augmentDots.attribute.dots =
  
  ## Records the number of augmentation dots required by a written dotted duration.
  attribute dots { data.AUGMENTDOT }?
sch:pattern [
  id =
    "wegaWorks-att.augmentDots-dots-dots_attribute_requires_dur-constraint-rule-6"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "mei:*[@dots]"
    "\x{a}" ~
    "              "
    sch:assert [
      test = "@dur"
      "An element with a dots attribute must also have a dur\x{a}" ~
      "                attribute."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
att.authorized.attributes =
  att.canonical.attributes,
  att.authorized.attribute.auth,
  att.authorized.attribute.auth.uri
att.authorized.attribute.auth =
  
  ## A name or label associated with a controlled vocabulary or other authoritative source for this element or its content.
  attribute auth { xsd:string }?
att.authorized.attribute.auth.uri =
  
  ## A web-accessible location of the controlled vocabulary or other authoritative source of identification or definition for this element or its content. This attribute may contain a complete URI or a partial URI which is completed by the value of the codedval attribute.
  attribute auth.uri { data.URI }?
att.basic.attributes = att.id.attributes, att.basic.attribute.xmlbase
att.basic.attribute.xmlbase =
  
  ## Provides a base URI reference with which applications can resolve relative URI references into absolute URI references.
  attribute xml:base { data.URI }?
att.bibl.attributes = att.bibl.attribute.analog
att.bibl.attribute.analog =
  
  ## Contains a reference to a field or element in another descriptive encoding system to which this MEI element is comparable.
  attribute analog { xsd:string }?
att.calendared.attributes = att.calendared.attribute.calendar
att.calendared.attribute.calendar =
  
  ## Indicates the calendar system to which a date belongs, for example, Gregorian, Julian, Roman, Mosaic, Revolutionary, Islamic, etc.
  attribute calendar { xsd:NMTOKEN }?
att.canonical.attributes = att.canonical.attribute.codedval
att.canonical.attribute.codedval =
  [
    a:documentation [
      "A value that represents or identifies other data. Often, it is a primary key in the database or a unique value in the coded list identified by the "
      ns1:code [ "@auth" ]
      " or "
      ns1:code [ "@auth.uri" ]
      " attributes."
    ]
  ]
  attribute codedval {
    list { xsd:NMTOKEN+ }
  }?
att.chord.log.attributes =
  att.articulation.attributes,
  att.augmentDots.attributes,
  att.chord.log.cmn.attributes,
  att.cue.attributes,
  att.duration.logical.attributes,
  att.event.attributes,
  att.sylText.attributes
att.classed.attributes = att.classed.attribute.class
att.classed.attribute.class =
  
  ## Contains one or more URIs which denote classification terms that apply to the entity bearing this attribute.
  attribute class {
    list { data.URI+ }
  }?
sch:pattern [
  id = "wegaWorks-att.classed-class-check_classURI-constraint-rule-7"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@class"
    "\x{a}" ~
    "              "
    sch:assert [
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:category/@xml:id or matches($i, '^([a-z]+://|\.{1,2}/)')"
      "The value in @class must either correspond to the @xml:id attribute of a category\x{a}" ~
      "                element or be an external URL."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
att.clef.log.attributes =
  att.clefShape.attributes,
  att.lineLoc.attributes,
  att.octave.attributes,
  att.octaveDisplacement.attributes,
  att.clef.log.attribute.cautionary
att.clef.log.attribute.cautionary =
  
  ## Records the function of the clef. A "cautionary" clef does not change the following pitches.
  attribute cautionary { data.BOOLEAN }?
att.cleffing.log.attributes =
  att.cleffing.log.attribute.clef.shape,
  att.cleffing.log.attribute.clef.line,
  att.cleffing.log.attribute.clef.dis,
  att.cleffing.log.attribute.clef.dis.place
att.cleffing.log.attribute.clef.shape =
  
  ## Encodes a value for the clef symbol.
  attribute clef.shape { data.CLEFSHAPE }?
att.cleffing.log.attribute.clef.line =
  
  ## Contains a default value for the position of the clef. The value must be in the range between 1 and the number of lines on the staff. The numbering of lines starts with the lowest line of the staff.
  attribute clef.line { data.CLEFLINE }?
att.cleffing.log.attribute.clef.dis =
  
  ## Records the amount of octave displacement to be applied to the clef.
  attribute clef.dis { data.OCTAVE.DIS }?
att.cleffing.log.attribute.clef.dis.place =
  
  ## Records the direction of octave displacement to be applied to the clef.
  attribute clef.dis.place { data.STAFFREL.basic }?
sch:pattern [
  id =
    "wegaWorks-att.cleffing.log-clef_shape_requires_clef_line-constraint-rule-8"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "mei:*[matches(@clef.shape, '[FCG]')]"
    "\x{a}" ~
    "          "
    sch:assert [
      test = "@clef.line"
      "An 'F', 'C', or 'G' clef requires that its position be\x{a}" ~
      "            specified."
    ]
    "\x{a}" ~
    "        "
  ]
  "\x{a}" ~
  "      "
  sch:rule [
    context = "mei:*[matches(@clef.shape, '(TAB|perc)')]"
    "\x{a}" ~
    "          "
    sch:assert [
      test = "@lines"
      "A TAB or percussion clef requires that the number of lines be\x{a}" ~
      "            specified."
    ]
    "\x{a}" ~
    "        "
  ]
  "\x{a}" ~
  "   "
]
att.clefShape.attributes = att.clefShape.attribute.shape
att.clefShape.attribute.shape =
  
  ## Describes a clef's shape.
  attribute shape { data.CLEFSHAPE }?
sch:pattern [
  id = "wegaWorks-att.clefShape-shape_requires_line-constraint-rule-10"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "mei:clef[matches(@shape, '[FCG]')]"
    "\x{a}" ~
    "          "
    sch:assert [
      test = "@line"
      "When @shape is present, @line must also be\x{a}" ~
      "            specified."
    ]
    "\x{a}" ~
    "        "
  ]
  "\x{a}" ~
  "   "
]
att.color.attributes = att.color.attribute.color
att.color.attribute.color =
  
  ## Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
  attribute color { data.COLOR }?
att.coloration.attributes = att.coloration.attribute.colored
att.coloration.attribute.colored =
  
  ## Indicates this feature is 'colored'; that is, it is a participant in a change in rhythmic values. In mensural notation, coloration is indicated by colored notes (red, black, etc.) where void notes would otherwise occur. In CMN, coloration is indicated by an inverse color; that is, the note head is void when it would otherwise be filled and vice versa.
  attribute colored { data.BOOLEAN }?
att.common.attributes =
  att.basic.attributes,
  att.labelled.attributes,
  att.linking.attributes,
  att.nNumberLike.attributes,
  att.responsibility.attributes,
  att.typed.attributes
att.controlEvent.attributes =
  att.layerIdent.attributes,
  att.partIdent.attributes,
  att.plist.attributes,
  att.staffIdent.attributes,
  att.targetEval.attributes,
  att.timestamp.logical.attributes
att.cue.attributes = att.cue.attribute.cue
att.cue.attribute.cue =
  
  ##
  attribute cue { data.BOOLEAN }?
att.datable.attributes =
  att.datable.attribute.enddate,
  att.datable.attribute.isodate,
  att.datable.attribute.notafter,
  att.datable.attribute.notbefore,
  att.datable.attribute.startdate
att.datable.attribute.enddate =
  
  ## Contains the end point of a date range in standard ISO form.
  attribute enddate { data.ISODATE }?
att.datable.attribute.isodate =
  
  ## Provides the value of a textual date in standard ISO form.
  attribute isodate { data.ISODATE }?
att.datable.attribute.notafter =
  
  ## Contains an upper boundary for an uncertain date in standard ISO form.
  attribute notafter { data.ISODATE }?
att.datable.attribute.notbefore =
  
  ## Contains a lower boundary, in standard ISO form, for an uncertain date.
  attribute notbefore { data.ISODATE }?
att.datable.attribute.startdate =
  
  ## Contains the starting point of a date range in standard ISO form.
  attribute startdate { data.ISODATE }?
att.dataPointing.attributes = att.dataPointing.attribute.data
att.dataPointing.attribute.data =
  
  ## Used to link metadata elements to one or more data-containing elements.
  attribute data {
    list { data.URI+ }
  }?
sch:pattern [
  id =
    "wegaWorks-att.dataPointing-data-check_dataTarget-constraint-rule-11"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@data"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@data attribute should\x{a}" ~
      "                have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*[ancestor::mei:music]/@xml:id"
      "The value in @data should correspond to the @xml:id attribute of a descendant of\x{a}" ~
      "                the music element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
att.mdiv.log.attributes = empty
att.metadataPointing.attributes = att.metadataPointing.attribute.decls
att.metadataPointing.attribute.decls =
  
  ## Identifies one or more metadata elements (other than classification terms) within the header, which are understood to apply to the element bearing this attribute and its content.
  attribute decls {
    list { data.URI+ }
  }?
sch:pattern [
  id =
    "wegaWorks-att.metadataPointing-decls-check_declsTarget-constraint-rule-12"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@decls"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@decls attribute\x{a}" ~
      "                should have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*[ancestor::mei:meiHead]/@xml:id"
      "Each value in @decls should correspond to the @xml:id attribute of an element\x{a}" ~
      "                within the metadata header."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      test =
        "every $i in tokenize(., '\s+') satisfies not(substring($i,2)=//mei:term/@xml:id)"
      "No value in @decls should correspond to the @xml:id attribute of a classification\x{a}" ~
      "                term. Use @class for this purpose."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
att.dir.log.attributes =
  att.controlEvent.attributes,
  att.duration.additive.attributes,
  att.startEndId.attributes,
  att.timestamp2.logical.attributes
att.duration.additive.attributes = att.duration.additive.attribute.dur
att.duration.additive.attribute.dur =
  
  ## When a duration cannot be represented as a single power-of-two value, multiple space-separated values that add up to the total duration may be used.
  attribute dur {
    list { data.DURATION+ }
  }?
att.duration.default.attributes =
  att.duration.default.attribute.dur.default,
  att.duration.default.attribute.num.default,
  att.duration.default.attribute.numbase.default
att.duration.default.attribute.dur.default =
  
  ## Contains a default duration in those situations when the first note, rest, chord, etc. in a measure does not have a duration specified.
  attribute dur.default { data.DURATION }?
att.duration.default.attribute.num.default =
  
  ## Along with numbase.default, describes the default duration as a ratio. num.default is the first value in the ratio.
  attribute num.default { xsd:positiveInteger }?
att.duration.default.attribute.numbase.default =
  
  ## Along with num.default, describes the default duration as a ratio. numbase.default is the second value in the ratio.
  attribute numbase.default { xsd:positiveInteger }?
att.duration.logical.attributes = att.duration.logical.attribute.dur
att.duration.logical.attribute.dur =
  
  ## Records the duration of a feature using the relative durational values provided by the data.DURATION datatype.
  attribute dur { data.DURATION }?
att.duration.ratio.attributes =
  att.duration.ratio.attribute.num, att.duration.ratio.attribute.numbase
att.duration.ratio.attribute.num =
  
  ## Along with numbase, describes duration as a ratio. num is the first value in the ratio, while numbase is the second.
  attribute num { xsd:positiveInteger }?
att.duration.ratio.attribute.numbase =
  
  ## Along with num, describes duration as a ratio. num is the first value in the ratio, while numbase is the second.
  attribute numbase { xsd:positiveInteger }?
att.dynam.log.attributes =
  att.controlEvent.attributes,
  att.duration.additive.attributes,
  att.startEndId.attributes,
  att.timestamp2.logical.attributes
att.event.attributes =
  att.layerIdent.attributes,
  att.staffIdent.attributes,
  att.timestamp.logical.attributes
att.evidence.attributes =
  att.evidence.attribute.cert, att.evidence.attribute.evidence
att.evidence.attribute.cert =
  
  ## Signifies the degree of certainty or precision associated with a feature.
  attribute cert { data.CERTAINTY }?
att.evidence.attribute.evidence =
  
  ## Indicates the nature of the evidence supporting the reliability or accuracy of the intervention or interpretation.
  ## Suggested values include: 1] internal; 2] external; 3] conjecture
  attribute evidence {
    
    ## There is evidence within the document to support the intervention.
    "internal"
    | 
      ## There is evidence outside the document to support the intervention.
      "external"
    | 
      ## The assertion has been made by the editor, cataloguer, or scholar on the basis of their expertise.
      "conjecture"
    | xsd:NMTOKEN
  }?
att.extent.attributes =
  att.measurement.attributes,
  att.ranging.attributes,
  att.extent.attribute.extent
att.extent.attribute.extent =
  
  ## Captures a measurement, count, or description. When extent contains a numeric value, use the unit attribute to indicate the measurement unit.
  attribute extent { xsd:string }?
sch:pattern [
  id = "wegaWorks-att.extent-extent-check_extent-constraint-rule-13"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@extent[matches(normalize-space(.), '^\d+(\.\d+)?$')]"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "../@unit"
      "The @unit attribute is\x{a}" ~
      "                recommended."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@extent[matches(., '\d+(\.\d+)?\s')]"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "../@unit"
      "Separation into value (@extent) and unit\x{a}" ~
      "                (@unit) is recommended."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
att.filing.attributes = att.filing.attribute.nonfiling
att.filing.attribute.nonfiling =
  
  ## Holds the number of initial characters (such as those constituting an article or preposition) that should not be used for sorting a title or name.
  attribute nonfiling { xsd:positiveInteger }?
att.handIdent.attributes = att.handIdent.attribute.hand
att.handIdent.attribute.hand =
  [
    a:documentation [
      "Signifies the hand responsible for an action. The value must be the ID of a "
      ns1:code [ "<hand>" ]
      " element declared in the header."
    ]
  ]
  attribute hand { data.URI }?
sch:pattern [
  id =
    "wegaWorks-att.handIdent-hand-check_handTarget-constraint-rule-15"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@hand"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@hand attribute should\x{a}" ~
      "                have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:hand/@xml:id"
      "Each value in @hand should correspond to the @xml:id attribute of a hand\x{a}" ~
      "                element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
att.horizontalAlign.attributes = att.horizontalAlign.attribute.halign
att.horizontalAlign.attribute.halign =
  
  ## Records horizontal alignment.
  attribute halign { data.HORIZONTALALIGNMENT }?
att.id.attributes = att.id.attribute.xmlid
att.id.attribute.xmlid =
  
  ## Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
  attribute xml:id { xsd:ID }?
att.internetMedia.attributes = att.internetMedia.attribute.mimetype
att.internetMedia.attribute.mimetype =
  
  ## Specifies the applicable MIME (multimedia internet mail extension) type. The value should be a valid MIME media type defined by the Internet Engineering Task Force in RFC 2046.
  attribute mimetype { xsd:string }?
att.keySigDefault.log.attributes =
  att.keySigDefault.log.attribute.key.sig
att.keySigDefault.log.attribute.key.sig =
  
  ## Written key signature.
  attribute key.sig {
    list { data.KEYFIFTHS+ }
  }?
att.labelled.attributes = att.labelled.attribute.label
att.labelled.attribute.label =
  
  ## Captures text to be used to generate a label for the element to which it's attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
  attribute label { xsd:string }?
att.lang.attributes =
  att.lang.attribute.xmllang, att.lang.attribute.translit
att.lang.attribute.xmllang =
  
  ## Identifies the language of the element's content. The values for this attribute are language 'tags' as defined in BCP 47. All language tags that make use of private use sub-tags must be documented in a corresponding language element in the MEI header whose id attribute is the same as the language tag's value.
  attribute xml:lang { xsd:language }?
att.lang.attribute.translit =
  
  ## Specifies the transliteration technique used.
  attribute translit { xsd:NMTOKEN }?
att.layer.log.attributes =
  att.meterConformance.attributes, att.layer.log.attribute.def
att.layer.log.attribute.def =
  
  ## Provides a mechanism for linking the layer to a layerDef element.
  attribute def { data.URI }?
sch:pattern [
  id =
    "wegaWorks-att.layer.log-def-check_defTarget_layer-constraint-rule-16"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "mei:layer/@def"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@def attribute should\x{a}" ~
      "                have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:layerDef/@xml:id"
      "The value in @def should correspond to the @xml:id attribute of a layerDef\x{a}" ~
      "                element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
att.layerIdent.attributes = att.layerIdent.attribute.layer
att.layerIdent.attribute.layer =
  
  ## Identifies the layer to which a feature applies.
  attribute layer {
    list { xsd:positiveInteger+ }
  }?
att.lineLoc.attributes = att.lineLoc.attribute.line
att.lineLoc.attribute.line =
  
  ## Indicates the line upon which a feature stands. The value must be in the range between 1 and the number of lines on the staff. The numbering of lines starts with the lowest line of the staff.
  attribute line { data.CLEFLINE }?
att.linking.attributes =
  att.linking.attribute.copyof,
  att.linking.attribute.corresp,
  att.linking.attribute.follows,
  att.linking.attribute.next,
  att.linking.attribute.precedes,
  att.linking.attribute.prev,
  att.linking.attribute.sameas,
  att.linking.attribute.synch
att.linking.attribute.copyof =
  
  ## Points to an element of which the current element is a copy.
  attribute copyof { data.URI }?
sch:pattern [
  id =
    "wegaWorks-att.linking-copyof-When_copyof_element_empty-constraint-rule-17"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "mei:*[@copyof]"
    "\x{a}" ~
    "              "
    sch:assert [
      test =
        "count(child::*[not(comment() or processing-instruction())]) = 0"
      "An\x{a}" ~
      "                element with a copyof attribute can only have comment or processing instruction\x{a}" ~
      "                descendents."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
sch:pattern [
  id =
    "wegaWorks-att.linking-copyof-check_copyofTarget-constraint-rule-18"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@copyof"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@copyof attribute\x{a}" ~
      "                should have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id"
      "The\x{a}" ~
      "                value in @copyof should correspond to the @xml:id attribute of an\x{a}" ~
      "                element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
att.linking.attribute.corresp =
  
  ## Used to point to other elements that correspond to this one in a generic fashion.
  attribute corresp {
    list { data.URI+ }
  }?
sch:pattern [
  id =
    "wegaWorks-att.linking-corresp-check_correspTarget-constraint-rule-19"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@corresp"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@corresp attribute\x{a}" ~
      "                should have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id"
      "Each\x{a}" ~
      "                value in @corresp should correspond to the @xml:id attribute of an\x{a}" ~
      "                element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
att.linking.attribute.follows =
  
  ## points to one or more events in a user-defined collection that are known to be predecessors of the current element.
  attribute follows {
    list { data.URI+ }
  }?
sch:pattern [
  id =
    "wegaWorks-att.linking-follows-check_followsTarget-constraint-rule-20"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@follows"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@follows attribute\x{a}" ~
      "                should have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id"
      "Each\x{a}" ~
      "                value in @follows must correspond to the @xml:id attribute of an\x{a}" ~
      "                element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
att.linking.attribute.next =
  
  ## Used to point to the next event(s) in a user-defined collection.
  attribute next {
    list { data.URI+ }
  }?
sch:pattern [
  id = "wegaWorks-att.linking-next-check_nextTarget-constraint-rule-21"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@next"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@next attribute should\x{a}" ~
      "                have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id"
      "Each\x{a}" ~
      "                value in @next should correspond to the @xml:id attribute of an\x{a}" ~
      "                element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
att.linking.attribute.precedes =
  
  ## Points to one or more events in a user-defined collection that are known to be successors of the current element.
  attribute precedes {
    list { data.URI+ }
  }?
sch:pattern [
  id =
    "wegaWorks-att.linking-precedes-check_precedesTarget-constraint-rule-22"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@precedes"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@precedes attribute\x{a}" ~
      "                should have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id"
      "Each\x{a}" ~
      "                value in @precedes must correspond to the @xml:id attribute of an\x{a}" ~
      "                element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
att.linking.attribute.prev =
  
  ## Points to the previous event(s) in a user-defined collection.
  attribute prev {
    list { data.URI+ }
  }?
sch:pattern [
  id = "wegaWorks-att.linking-prev-check_prevTarget-constraint-rule-23"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@prev"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@prev attribute should\x{a}" ~
      "                have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id"
      "Each\x{a}" ~
      "                value in @prev should correspond to the @xml:id attribute of an\x{a}" ~
      "                element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
att.linking.attribute.sameas =
  
  ## Points to an element that is the same as the current element but is not a literal copy of the current element.
  attribute sameas {
    list { data.URI+ }
  }?
sch:pattern [
  id =
    "wegaWorks-att.linking-sameas-check_sameasTarget-constraint-rule-24"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@sameas"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@sameas attribute\x{a}" ~
      "                should have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id"
      "Each\x{a}" ~
      "                value in @sameas should correspond to the @xml:id attribute of an\x{a}" ~
      "                element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
att.linking.attribute.synch =
  
  ## Points to elements that are synchronous with the current element.
  attribute synch {
    list { data.URI+ }
  }?
sch:pattern [
  id =
    "wegaWorks-att.linking-synch-check_synchTarget-constraint-rule-25"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@synch"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@synch attribute\x{a}" ~
      "                should have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id"
      "Each\x{a}" ~
      "                value in @synch should correspond to the @xml:id attribute of an\x{a}" ~
      "                element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
att.measurement.attributes = att.measurement.attribute.unit
att.measurement.attribute.unit =
  
  ## indicates the unit used for a measurement of size.
  attribute unit {
    
    ## (page) the element contains a page number or a block of text.
    "pp"
    | 
      ## (volume) the element contains a number of a volume
      "vol"
    | 
      ## (column) the element contains a number of columns or a block of columns.
      "col"
    | 
      ## (folio) the element contains a folio number or a block of folios.
      "fol"
    | 
      ## (centimeter) the element contains the ammount of centimeters.
      "cm"
  }?
att.medium.attributes = att.medium.attribute.medium
att.medium.attribute.medium =
  
  ## Describes the writing medium.
  attribute medium { xsd:string }?
att.meiVersion.attributes = att.meiVersion.attribute.meiversion
att.meiVersion.attribute.meiversion =
  
  ## Specifies a generic MEI version label.
  [ a:defaultValue = "4.0.1" ]
  attribute meiversion {
    
    ## First release of MEI 4
    "4.0.0"
    | 
      ## Bugfix Release 4.0.1
      "4.0.1"
  }?
att.meterConformance.attributes = att.meterConformance.attribute.metcon
att.meterConformance.attribute.metcon =
  
  ## Indicates the relationship between the content of a staff or layer and the prevailing meter.
  attribute metcon {
    
    ## Complete; i.e., conformant with the prevailing meter.
    "c"
    | 
      ## Incomplete; i.e., not enough beats.
      "i"
    | 
      ## Overfull; i.e., too many beats.
      "o"
  }?
att.meterConformance.bar.attributes =
  att.meterConformance.bar.attribute.metcon,
  att.meterConformance.bar.attribute.control
att.meterConformance.bar.attribute.metcon =
  
  ## Indicates the relationship between the content of a measure and the prevailing meter.
  attribute metcon { data.BOOLEAN }?
att.meterConformance.bar.attribute.control =
  [
    a:documentation [
      'Indicates whether or not a bar line is "controlling"; that is, if it indicates a point of alignment across all the parts. Bar lines within a score are usually controlling; that is, they "line up". Bar lines within parts may or may not be controlling. When applied to '
      ns1:code [ "<measure>" ]
      ", this attribute indicates the nature of the right barline but not the left."
    ]
  ]
  attribute control { data.BOOLEAN }?
att.meterSigDefault.log.attributes =
  att.meterSigDefault.log.attribute.meter.count,
  att.meterSigDefault.log.attribute.meter.unit,
  att.meterSigDefault.log.attribute.meter.sym
att.meterSigDefault.log.attribute.meter.count =
  
  ## Captures the number of beats in a measure, that is, the top number of the meter signature. It must contain a decimal number or an additive expression that evaluates to a decimal number, such as 2+3.
  attribute meter.count {
    xsd:string { pattern = "\d+(\.\d+)?(\s*\+\s*\d+(\.\d+)?)*" }
  }?
att.meterSigDefault.log.attribute.meter.unit =
  
  ## Contains the number indicating the beat unit, that is, the bottom number of the meter signature.
  attribute meter.unit { xsd:decimal }?
att.meterSigDefault.log.attribute.meter.sym =
  
  ## Indicates the use of a meter symbol instead of a numeric meter signature, that is, 'C' for common time or 'C' with a slash for cut time.
  attribute meter.sym { data.METERSIGN }?
att.mmTempo.attributes =
  att.mmTempo.attribute.mm,
  att.mmTempo.attribute.mm.unit,
  att.mmTempo.attribute.mm.dots
att.mmTempo.attribute.mm =
  
  ## Used to describe tempo in terms of beats (often the meter signature denominator) per minute, ala M.M. (Maezel's Metronome). Do not confuse this attribute with midi.bpm or midi.mspb. In MIDI, a beat is always defined as a quarter note, *not the numerator of the time signature or the metronomic indication*.
  attribute mm { data.TEMPOVALUE }?
att.mmTempo.attribute.mm.unit =
  
  ## Captures the metronomic unit.
  attribute mm.unit { data.DURATION }?
att.mmTempo.attribute.mm.dots =
  
  ## Records the number of augmentation dots required by a dotted metronome unit.
  attribute mm.dots { data.AUGMENTDOT }?
att.name.attributes =
  att.authorized.attributes,
  att.datable.attributes,
  att.filing.attributes,
  att.name.attribute.nymref,
  att.name.attribute.role
att.name.attribute.nymref =
  
  ## Used to record a pointer to the regularized form of the name elsewhere in the document.
  attribute nymref { data.URI }?
sch:pattern [
  id = "wegaWorks-att.name-nymref-check_nymrefTarget-constraint-rule-26"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@nymref"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@nymref attribute\x{a}" ~
      "                should have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id"
      "The\x{a}" ~
      "                value in @nymref should correspond to the @xml:id attribute of an\x{a}" ~
      "                element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
att.name.attribute.role =
  
  ## Used to specify further information about the entity referenced by this name, for example, the occupation of a person or the status of a place.
  attribute role { text }?
att.nInteger.attributes = att.nInteger.attribute.n
att.nInteger.attribute.n =
  
  ## Provides a numeric designation that indicates an element's position in a sequence of similar elements. Its value must be a non-negative integer.
  attribute n { xsd:nonNegativeInteger }?
att.nNumberLike.attributes = att.nNumberLike.attribute.n
att.nNumberLike.attribute.n =
  
  ## Provides a number-like designation that indicates an element's position in a sequence of similar elements. May not contain space characters.
  attribute n { data.WORD }?
att.note.log.attributes =
  att.augmentDots.attributes,
  att.coloration.attributes,
  att.cue.attributes,
  att.duration.logical.attributes,
  att.event.attributes,
  att.note.log.cmn.attributes,
  att.pitched.attributes
att.octave.attributes = att.octave.attribute.oct
att.octave.attribute.oct =
  
  ## Captures written octave information.
  attribute oct { data.OCTAVE }?
att.octaveDefault.attributes = att.octaveDefault.attribute.oct.default
att.octaveDefault.attribute.oct.default =
  
  ## Contains a default octave specification for use when the first note, rest, chord, etc. in a measure does not have an octave value specified.
  attribute oct.default { data.OCTAVE }?
att.octaveDisplacement.attributes =
  att.octaveDisplacement.attribute.dis,
  att.octaveDisplacement.attribute.dis.place
att.octaveDisplacement.attribute.dis =
  
  ## Records the amount of octave displacement.
  attribute dis { data.OCTAVE.DIS }?
att.octaveDisplacement.attribute.dis.place =
  
  ## Records the direction of octave displacement.
  attribute dis.place { data.STAFFREL.basic }?
att.origin.layerIdent.attributes =
  att.origin.layerIdent.attribute.origin.layer
att.origin.layerIdent.attribute.origin.layer =
  
  ## identifies the layer on which referenced notation occurs.
  attribute origin.layer {
    list { xsd:positiveInteger+ }
  }?
att.origin.staffIdent.attributes =
  att.origin.staffIdent.attribute.origin.staff
att.origin.staffIdent.attribute.origin.staff =
  
  ## signifies the staff on which referenced notation occurs. Defaults to the same value as the local staff. Mandatory when applicable.
  attribute origin.staff {
    list { xsd:positiveInteger+ }
  }?
att.origin.startEndId.attributes =
  att.origin.startEndId.attribute.origin.startid,
  att.origin.startEndId.attribute.origin.endid
att.origin.startEndId.attribute.origin.startid =
  
  ## indicates the first element in a sequence of events.
  attribute origin.startid { data.URI }?
att.origin.startEndId.attribute.origin.endid =
  
  ## indicates the final element in a sequence of events.
  attribute origin.endid { data.URI }?
att.origin.timestamp.logical.attributes =
  att.origin.timestamp.logical.attribute.origin.tstamp,
  att.origin.timestamp.logical.attribute.origin.tstamp2
att.origin.timestamp.logical.attribute.origin.tstamp =
  
  ## encodes the starting point of musical material in terms of musical time, i.e., a (potentially negative) count of measures plus a beat location.
  attribute origin.tstamp { data.MEASUREBEATOFFSET }?
att.origin.timestamp.logical.attribute.origin.tstamp2 =
  [
    a:documentation [
      "encodes the ending point of musical material in terms of musical time, i.e., a count of measures plus a beat location. The values are relative to the measure identified by "
      ns1:code [ "@origin.tstamp" ]
      "."
    ]
  ]
  attribute origin.tstamp2 { data.MEASUREBEAT }?
sch:pattern [
  id =
    "wegaWorks-att.origin.timestamp.logical-origin.tstamp2-origin.tstamp2_requires_origin.tstamp-constraint-rule-27"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "mei:*[@origin.tstamp2]"
    "\x{a}" ~
    "              "
    sch:assert [
      test = "@origin.tstamp"
      "When @origin.tstamp2 is used @origin.tstamp must\x{a}" ~
      "                also be present."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
att.partIdent.attributes =
  att.partIdent.attribute.part, att.partIdent.attribute.partstaff
att.partIdent.attribute.part =
  
  ## Indicates the part in which the current feature should appear. Use '%all' when the feature should occur in every part.
  attribute part {
    list {
      xsd:token { pattern = "(%all|#[\i][\c]+)" }+
    }
  }?
sch:pattern [
  id =
    "wegaWorks-att.partIdent-part-check_part_attr_all-constraint-rule-28"
  "\x{a}" ~
  "      "
  sch:rule [
    context =
      "@part[some $i in tokenize(., '\s+') satisfies (matches($i, '^%all$'))]"
    "\x{a}" ~
    "              "
    sch:assert [
      test = "count(tokenize(., '\s+')) = 1"
      "'%all' cannot be mixed with other\x{a}" ~
      "                values."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
att.partIdent.attribute.partstaff =
  
  ## Signifies the part staff on which a notated feature occurs. Use '%all' when the feature should occur on every staff.
  attribute partstaff {
    list {
      xsd:token { pattern = "(%all|\d+(-\d+)?)" }+
    }
  }?
sch:pattern [
  id =
    "wegaWorks-att.partIdent-partstaff-check_partstaff_attr_all-constraint-rule-29"
  "\x{a}" ~
  "      "
  sch:rule [
    context =
      "@partstaff[some $i in tokenize(., '\s+') satisfies (matches($i, '^%all$'))]"
    "\x{a}" ~
    "              "
    sch:assert [
      test = "count(tokenize(., '\s+')) = 1"
      "'%all' cannot be mixed with other\x{a}" ~
      "                values."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
att.pitch.attributes = att.pitch.attribute.pname
att.pitch.attribute.pname =
  
  ## Contains a written pitch name.
  attribute pname { data.PITCHNAME }?
att.pitched.attributes = att.pitch.attributes, att.octave.attributes
att.plist.attributes = att.plist.attribute.plist
att.plist.attribute.plist =
  
  ## When the target attribute is present, plist identifies the active participants; that is, those entities pointed "from", in a relationship with the specified target(s). When the target attribute is not present, it identifies participants in a mutual relationship.
  attribute plist {
    list { data.URI+ }
  }?
sch:pattern [
  id = "wegaWorks-att.plist-plist-check_plistTarget-constraint-rule-30"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@plist"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@plist attribute\x{a}" ~
      "                should have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id"
      "Each\x{a}" ~
      "                value in @plist should correspond to the @xml:id attribute of an\x{a}" ~
      "                element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
att.pointing.attributes =
  att.pointing.attribute.xlinkactuate,
  att.pointing.attribute.xlinkrole,
  att.pointing.attribute.xlinkshow,
  att.pointing.attribute.target,
  att.pointing.attribute.targettype
att.pointing.attribute.xlinkactuate =
  
  ## Defines whether a link occurs automatically or must be requested by the user.
  attribute xlink:actuate {
    
    ## Load the target resource(s) immediately.
    "onLoad"
    | 
      ## Load the target resource(s) upon user request.
      "onRequest"
    | 
      ## Do not permit loading of the target resource(s).
      "none"
    | 
      ## Behavior other than allowed by the other values of this attribute.
      "other"
  }?
att.pointing.attribute.xlinkrole =
  
  ## Characterization of the relationship between resources. The value of the role attribute must be a URI.
  attribute xlink:role { data.URI }?
att.pointing.attribute.xlinkshow =
  
  ## Defines how a remote resource is rendered.
  attribute xlink:show {
    
    ## Open in a new window.
    "new"
    | 
      ## Load the referenced resource in the same window.
      "replace"
    | 
      ## Embed the referenced resource at the point of the link.
      "embed"
    | 
      ## Do not permit traversal to the referenced resource.
      "none"
    | 
      ## Behavior other than permitted by the other values of this attribute.
      "other"
  }?
att.pointing.attribute.target =
  
  ## Identifies passive participants in a relationship; that is, the entities pointed "to".
  attribute target {
    list { data.URI+ }
  }?
att.pointing.attribute.targettype =
  
  ## Characterization of target resource(s) using any convenient classification scheme or typology.
  attribute targettype { xsd:NMTOKEN }?
att.quantity.attributes =
  att.measurement.attributes,
  att.ranging.attributes,
  att.quantity.attribute.quantity
att.quantity.attribute.quantity =
  
  ## Numeric value capturing a measurement or count. Can only be interpreted in combination with the unit attribute.
  attribute quantity {
    xsd:decimal { minInclusive = "0" }
  }?
att.ranging.attributes =
  att.ranging.attribute.atleast,
  att.ranging.attribute.atmost,
  att.ranging.attribute.min,
  att.ranging.attribute.max,
  att.ranging.attribute.confidence
att.ranging.attribute.atleast =
  
  ## Gives a minimum estimated value for an approximate measurement.
  attribute atleast { xsd:decimal }?
att.ranging.attribute.atmost =
  
  ## Gives a maximum estimated value for an approximate measurement.
  attribute atmost { xsd:decimal }?
att.ranging.attribute.min =
  
  ## Where the measurement summarizes more than one observation or a range of values, supplies the minimum value observed.
  attribute min { xsd:decimal }?
att.ranging.attribute.max =
  
  ## Where the measurement summarizes more than one observation or a range of values, supplies the maximum value observed.
  attribute max { xsd:decimal }?
att.ranging.attribute.confidence =
  
  ## Specifies the degree of statistical confidence (between zero and one) that a value falls within the range specified by min and max, or the proportion of observed values that fall within that range.
  attribute confidence { data.CONFIDENCE }?
sch:pattern [
  id =
    "wegaWorks-att.ranging-confidence-check_confidence-constraint-rule-31"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "mei:*[@confidence]"
    "\x{a}" ~
    "              "
    sch:assert [
      test = "@min and @max"
      "The attributes @min and @max are required when\x{a}" ~
      "                @confidence is present."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
att.responsibility.attributes = att.responsibility.attribute.resp
att.responsibility.attribute.resp =
  
  ## Indicates the agent(s) responsible for some aspect of the text's transcription, editing, or encoding. Its value must point to one or more identifiers declared in the document header.
  attribute resp {
    list { data.URI+ }
  }?
sch:pattern [
  id =
    "wegaWorks-att.responsibility-resp-check_respTarget-constraint-rule-32"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@resp"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@resp attribute should\x{a}" ~
      "                have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*[ancestor::mei:meiHead]/@xml:id"
      "The value in @resp should correspond to the @xml:id attribute of an element within\x{a}" ~
      "                the metadata header."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
att.rest.log.attributes =
  att.augmentDots.attributes,
  att.cue.attributes,
  att.duration.logical.attributes,
  att.event.attributes,
  att.rest.log.cmn.attributes
att.score.log.attributes = empty
att.scoreDef.log.attributes =
  att.cleffing.log.attributes,
  att.duration.default.attributes,
  att.keySigDefault.log.attributes,
  att.meterSigDefault.log.attributes,
  att.octaveDefault.attributes,
  att.transposition.attributes,
  att.scoreDef.log.cmn.attributes
att.section.log.attributes = empty
att.sequence.attributes = att.sequence.attribute.seq
att.sequence.attribute.seq =
  
  ## Used to assign a sequence number related to the order in which the encoded features carrying this attribute are believed to have occurred.
  attribute seq { xsd:positiveInteger }?
att.source.attributes = att.source.attribute.source
att.source.attribute.source =
  [
    a:documentation [
      "Contains a list of one or more pointers indicating the sources which attest to a given reading. Each value should correspond to the ID of a "
      ns1:code [ "<source>" ]
      " or "
      ns1:code [ "<manifestation>" ]
      "element located in the document header."
    ]
  ]
  attribute source {
    list { data.URI+ }
  }?
sch:pattern [
  id =
    "wegaWorks-att.source-source-check_sourceTarget-constraint-rule-33"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@source"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@source attribute\x{a}" ~
      "                should have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*[local-name() eq 'source' or local-name() eq 'manifestation']/@xml:id"
      "Each value in @source should correspond to the @xml:id attribute of a source or\x{a}" ~
      "                manifestation element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
att.space.log.attributes =
  att.augmentDots.attributes,
  att.duration.logical.attributes,
  att.event.attributes
att.staff.log.attributes =
  att.meterConformance.attributes, att.staff.log.attribute.def
att.staff.log.attribute.def =
  
  ## Provides a mechanism for linking the staff to a staffDef element.
  attribute def { data.URI }?
sch:pattern [
  id =
    "wegaWorks-att.staff.log-def-check_defTarget_staff-constraint-rule-34"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "mei:staff/@def"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@def attribute should\x{a}" ~
      "                have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:staffDef/@xml:id"
      "The value in @def should correspond to the @xml:id attribute of a staffDef\x{a}" ~
      "                element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
att.staffDef.log.attributes =
  att.cleffing.log.attributes,
  att.duration.default.attributes,
  att.keySigDefault.log.attributes,
  att.meterSigDefault.log.attributes,
  att.notationType.attributes,
  att.octaveDefault.attributes,
  att.transposition.attributes,
  att.staffDef.log.cmn.attributes,
  att.staffDef.log.attribute.lines
att.staffDef.log.attribute.lines =
  
  ## Indicates the number of staff lines.
  attribute lines { xsd:positiveInteger }?
att.staffGrp.log.attributes = empty
att.staffIdent.attributes = att.staffIdent.attribute.staff
att.staffIdent.attribute.staff =
  
  ## Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
  attribute staff {
    list { xsd:positiveInteger+ }
  }?
att.startEndId.attributes =
  att.startId.attributes, att.startEndId.attribute.endid
att.startEndId.attribute.endid =
  
  ## Indicates the final element in a sequence of events to which the feature applies.
  attribute endid { data.URI }?
sch:pattern [
  id =
    "wegaWorks-att.startEndId-endid-check_endidTarget-constraint-rule-35"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@endid"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@endid attribute\x{a}" ~
      "                should have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id"
      "The\x{a}" ~
      "                value in @endid should correspond to the @xml:id attribute of an\x{a}" ~
      "                element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
att.startId.attributes = att.startId.attribute.startid
att.startId.attribute.startid =
  
  ## Holds a reference to the first element in a sequence of events to which the feature applies.
  attribute startid { data.URI }?
sch:pattern [
  id =
    "wegaWorks-att.startId-startid-check_startidTarget-constraint-rule-36"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@startid"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@startid attribute\x{a}" ~
      "                should have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id"
      "The\x{a}" ~
      "                value in @startid should correspond to the @xml:id attribute of an\x{a}" ~
      "                element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
att.syl.log.attributes =
  att.syl.log.attribute.con, att.syl.log.attribute.wordpos
att.syl.log.attribute.con =
  
  ## Describes the symbols typically used to indicate breaks between syllables and their functions.
  attribute con {
    
    ## Space (word separator).
    "s"
    | 
      ## Dash (syllable separator).
      "d"
    | 
      ## Underscore (syllable extension).
      "u"
    | 
      ## Tilde (syllable elision).
      "t"
    | 
      ## Circumflex [angled line above] (syllable elision).
      "c"
    | 
      ## Caron [angled line below] (syllable elision).
      "v"
    | 
      ## Inverted breve [curved line above] (syllable elision).
      "i"
    | 
      ## Breve [curved line below] (syllable elision).
      "b"
  }?
att.syl.log.attribute.wordpos =
  
  ## Records the position of a syllable within a word.
  attribute wordpos {
    
    ## (initial) first syllable.
    "i"
    | 
      ## (medial) neither first nor last syllable.
      "m"
    | 
      ## (terminal) last syllable.
      "t"
  }?
att.sylText.attributes = att.sylText.attribute.syl
att.sylText.attribute.syl =
  
  ## Holds an associated sung text syllable.
  attribute syl { xsd:string }?
att.targetEval.attributes = att.targetEval.attribute.evaluate
att.targetEval.attribute.evaluate =
  
  ## Specifies the intended meaning when a participant in a relationship is itself a pointer.
  attribute evaluate {
    
    ## If an element pointed to is itself a pointer, then the target of that pointer will be taken, and so on, until an element is found which is not a pointer.
    "all"
    | 
      ## If an element pointed to is itself a pointer, then its target (whether a pointer or not) is taken as the target of this pointer.
      "one"
    | 
      ## No further evaluation of targets is carried out beyond that needed to find the element(s) specified in plist or target attribute.
      "none"
  }?
att.tempo.log.attributes =
  att.controlEvent.attributes,
  att.mmTempo.attributes,
  att.startId.attributes,
  att.tempo.log.attribute.func
att.tempo.log.attribute.func =
  
  ## Records the function of a tempo indication.
  attribute func {
    
    ## Marks a gradual change of tempo, such as "accel." or "rit."
    "continuous"
    | 
      ## Represents a static tempo instruction, such as a textual term like "Adagio", a metronome marking like "=70", or a combination of text and metronome indication.
      "instantaneous"
    | 
      ## Captures a change in pulse rate (tempo) and/or pulse grouping (subdivision) in an "equation" of the form [tempo before change] = [tempo after change].
      "metricmod"
    | 
      ## Indicates a change in pulse rate (tempo) and/or pulse grouping (subdivision) in an "equation" of the form [tempo after change] = [tempo before change]. The term "precedente" often appears following the "equation" to distinguish this kind of historical usage from the modern metric modulation form.
      "precedente"
  }?
att.textRendition.attributes =
  att.textRendition.attribute.altrend, att.textRendition.attribute.rend
att.textRendition.attribute.altrend =
  
  ## Used to extend the values of the rend attribute.
  attribute altrend {
    list { xsd:NMTOKEN+ }
  }?
att.textRendition.attribute.rend =
  
  ## Captures the appearance of the element's contents using MEI-defined descriptors.
  attribute rend {
    list { data.TEXTRENDITION+ }
  }?
att.timestamp.logical.attributes =
  att.timestamp.logical.attribute.tstamp
att.timestamp.logical.attribute.tstamp =
  
  ## Encodes the onset time in terms of musical time, i.e., beats[.fractional beat part], as expressed in the written time signature.
  attribute tstamp { data.BEAT }?
att.timestamp2.logical.attributes =
  att.timestamp2.logical.attribute.tstamp2
att.timestamp2.logical.attribute.tstamp2 =
  
  ## Encodes the ending point of an event, i.e., a count of measures plus a beat location in the ending measure.
  attribute tstamp2 { data.MEASUREBEAT }?
att.transposition.attributes =
  att.transposition.attribute.trans.diat,
  att.transposition.attribute.trans.semi
att.transposition.attribute.trans.diat =
  
  ## Records the amount of diatonic pitch shift, e.g., C to C = 0, C to D = 1, necessary to calculate the sounded pitch from the written one.
  attribute trans.diat { xsd:decimal }?
att.transposition.attribute.trans.semi =
  
  ## Records the amount of pitch shift in semitones, e.g., C to C = 1, C to D = 1, necessary to calculate the sounded pitch from the written one.
  attribute trans.semi { xsd:decimal }?
att.typed.attributes = att.classed.attributes, att.typed.attribute.type
att.typed.attribute.type =
  
  ## Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
  attribute type {
    list { xsd:NMTOKEN+ }
  }?
att.typography.attributes =
  att.typography.attribute.fontfam,
  att.typography.attribute.fontname,
  att.typography.attribute.fontsize,
  att.typography.attribute.fontstyle,
  att.typography.attribute.fontweight
att.typography.attribute.fontfam =
  
  ## Contains the name of a font-family.
  attribute fontfam { data.FONTFAMILY }?
att.typography.attribute.fontname =
  
  ## Holds the name of a font.
  attribute fontname { data.FONTNAME }?
att.typography.attribute.fontsize =
  
  ## Indicates the size of a font expressed in printers' points, i.e., 1/72nd of an inch, relative terms, e.g., "small", "larger", etc., or percentage values relative to "normal" size, e.g., "125%". 
  attribute fontsize { data.FONTSIZE }?
att.typography.attribute.fontstyle =
  
  ## Records the style of a font, i.e, italic, oblique, or normal.
  attribute fontstyle { data.FONTSTYLE }?
att.typography.attribute.fontweight =
  
  ## Used to indicate bold type.
  attribute fontweight { data.FONTWEIGHT }?
att.verticalAlign.attributes = att.verticalAlign.attribute.valign
att.verticalAlign.attribute.valign =
  
  ## Records vertical alignment.
  attribute valign { data.VERTICALALIGNMENT }?
att.whitespace.attributes = att.whitespace.attribute.xmlspace
att.whitespace.attribute.xmlspace =
  
  ## Allows one to signal to an application whether an element's white space is "significant". The behavior of xml:space cascades to all descendant elements, but it can be turned off locally by setting the xml:space attribute to the value "default".
  attribute xml:space {
    
    ## Allows the application to handle white space as necessary. Not including an xml:space attribute produces the same result as using the default value.
    "default"
    | 
      ## Instructs the application to maintain white space "as-is", suggesting that it might have meaning.
      "preserve"
  }?
att.xy.attributes = att.xy.attribute.x, att.xy.attribute.y
att.xy.attribute.x =
  
  ## Encodes an x coordinate for a feature in an output coordinate system. When it is necessary to record the placement of a feature in a facsimile image, use the facs attribute.
  attribute x { xsd:decimal }?
att.xy.attribute.y =
  
  ## Encodes a y coordinate for a feature in an output coordinate system. When it is necessary to record the placement of a feature in a facsimile image, use the facs attribute.
  attribute y { xsd:decimal }?
model.addressLike = address
model.addressLike_alternation = address
model.addressLike_sequence = address
model.addressLike_sequenceOptional = address?
model.addressLike_sequenceOptionalRepeatable = address*
model.addressLike_sequenceRepeatable = address+
model.annotLike = annot
model.annotLike_alternation = annot
model.annotLike_sequence = annot
model.annotLike_sequenceOptional = annot?
model.annotLike_sequenceOptionalRepeatable = annot*
model.annotLike_sequenceRepeatable = annot+
model.biblLike = bibl
model.biblLike_alternation = bibl
model.biblLike_sequence = bibl
model.biblLike_sequenceOptional = bibl?
model.biblLike_sequenceOptionalRepeatable = bibl*
model.biblLike_sequenceRepeatable = bibl+
model.chordPart = artic | note
model.controlEventLike = dir | dynam | tempo | cpMark
model.controlEventLike_alternation = dir | dynam | tempo | cpMark
model.controlEventLike_sequence = dir, dynam, tempo, cpMark
model.controlEventLike_sequenceOptional = dir?, dynam?, tempo?, cpMark?
model.controlEventLike_sequenceOptionalRepeatable =
  dir*, dynam*, tempo*, cpMark*
model.controlEventLike_sequenceRepeatable =
  dir+, dynam+, tempo+, cpMark+
model.dateLike = date
model.dateLike_alternation = date
model.dateLike_sequence = date
model.dateLike_sequenceOptional = date?
model.dateLike_sequenceOptionalRepeatable = date*
model.dateLike_sequenceRepeatable = date+
model.dimLike = notAllowed
model.dimLike_alternation = notAllowed
model.dimLike_sequence = empty
model.dimLike_sequenceOptional = empty
model.dimLike_sequenceOptionalRepeatable = empty
model.dimLike_sequenceRepeatable = notAllowed
model.editionLike = edition
model.editorialLike = abbr | expan
model.editorialLike_alternation = abbr | expan
model.editorialLike_sequence = abbr, expan
model.editorialLike_sequenceOptional = abbr?, expan?
model.editorialLike_sequenceOptionalRepeatable = abbr*, expan*
model.editorialLike_sequenceRepeatable = abbr+, expan+
model.endingLike = notAllowed
model.eventLike =
  model.keySigLike
  | model.meterSigLike
  | chord
  | clef
  | note
  | rest
  | space
model.headLike = notAllowed
model.identifierLike = identifier
model.identifierLike_alternation = identifier
model.identifierLike_sequence = identifier
model.identifierLike_sequenceOptional = identifier?
model.identifierLike_sequenceOptionalRepeatable = identifier*
model.identifierLike_sequenceRepeatable = identifier+
model.imprintPart = publisher | pubPlace
model.incipLike = incip
model.instrDefLike = notAllowed
model.keyAccidLike = notAllowed
model.keySigLike = notAllowed
model.keySigLike_alternation = notAllowed
model.keySigLike_sequence = empty
model.keySigLike_sequenceOptional = empty
model.keySigLike_sequenceOptionalRepeatable = empty
model.keySigLike_sequenceRepeatable = notAllowed
model.labelLike = label | labelAbbr
model.layerDefLike = notAllowed
model.layerLike = layer
model.layerLike_alternation = layer
model.layerLike_sequence = layer
model.layerLike_sequenceOptional = layer?
model.layerLike_sequenceOptionalRepeatable = layer*
model.layerLike_sequenceRepeatable = layer+
model.layerPart =
  model.eventLike
  | model.layerPart.mensuralAndNeumes
  | model.layerPart.cmn
model.layerPart.mensuralAndNeumes = notAllowed
model.lbLike = lb
model.lbLike_alternation = lb
model.lbLike_sequence = lb
model.lbLike_sequenceOptional = lb?
model.lbLike_sequenceOptionalRepeatable = lb*
model.lbLike_sequenceRepeatable = lb+
model.mdivLike = mdiv
model.measurementLike = model.numLike
model.measurementLike_alternation = model.numLike_alternation
model.measurementLike_sequence = model.numLike_sequence
model.measurementLike_sequenceOptional = model.numLike_sequenceOptional?
model.measurementLike_sequenceOptionalRepeatable =
  model.numLike_sequenceOptionalRepeatable*
model.measurementLike_sequenceRepeatable =
  model.numLike_sequenceRepeatable+
model.meterSigLike = notAllowed
model.meterSigLike_alternation = notAllowed
model.meterSigLike_sequence = empty
model.meterSigLike_sequenceOptional = empty
model.meterSigLike_sequenceOptionalRepeatable = empty
model.meterSigLike_sequenceRepeatable = notAllowed
model.milestoneLike.music = model.pbLike
model.milestoneLike.text = model.lbLike | model.pbLike
model.nameLike = name | model.nameLike.agent | model.nameLike.place
model.nameLike_alternation =
  name
  | model.nameLike.agent_alternation
  | model.nameLike.place_alternation
model.nameLike_sequence =
  name, model.nameLike.agent_sequence, model.nameLike.place_sequence
model.nameLike_sequenceOptional =
  name?,
  model.nameLike.agent_sequenceOptional?,
  model.nameLike.place_sequenceOptional?
model.nameLike_sequenceOptionalRepeatable =
  name*,
  model.nameLike.agent_sequenceOptionalRepeatable*,
  model.nameLike.place_sequenceOptionalRepeatable*
model.nameLike_sequenceRepeatable =
  name+,
  model.nameLike.agent_sequenceRepeatable+,
  model.nameLike.place_sequenceRepeatable+
model.noteModifierLike = accid | artic
model.numLike = notAllowed
model.numLike_alternation = notAllowed
model.numLike_sequence = empty
model.numLike_sequenceOptional = empty
model.numLike_sequenceOptionalRepeatable = empty
model.numLike_sequenceRepeatable = notAllowed
model.paracontentPart =
  model.textPhraseLike
  | model.lgLike
  | model.listLike
  | model.quoteLike
  | model.editLike
  | model.transcriptionLike
model.partsLike = notAllowed
model.pbLike = notAllowed
model.pbLike_alternation = notAllowed
model.pbLike_sequence = empty
model.pbLike_sequenceOptional = empty
model.pbLike_sequenceOptionalRepeatable = empty
model.pbLike_sequenceRepeatable = notAllowed
model.pLike = p
model.pLike_alternation = p
model.pLike_sequence = p
model.pLike_sequenceOptional = p?
model.pLike_sequenceOptionalRepeatable = p*
model.pLike_sequenceRepeatable = p+
model.relationLike = relation | relationList
model.relationLike_alternation = relation | relationList
model.relationLike_sequence = relation, relationList
model.relationLike_sequenceOptional = relation?, relationList?
model.relationLike_sequenceOptionalRepeatable = relation*, relationList*
model.relationLike_sequenceRepeatable = relation+, relationList+
model.rendLike = rend
model.rendLike_alternation = rend
model.rendLike_sequence = rend
model.rendLike_sequenceOptional = rend?
model.rendLike_sequenceOptionalRepeatable = rend*
model.rendLike_sequenceRepeatable = rend+
model.repositoryLike = repository
model.repositoryLike_alternation = repository
model.repositoryLike_sequence = repository
model.repositoryLike_sequenceOptional = repository?
model.repositoryLike_sequenceOptionalRepeatable = repository*
model.repositoryLike_sequenceRepeatable = repository+
model.resourceLike = notAllowed
model.respLikePart =
  arranger | author | composer | contributor | librettist | lyricist
model.scoreDefLike = scoreDef
model.scoreLike = score
model.scorePart =
  model.endingLike
  | model.scorePart.mensuralAndNeumes
  | model.sectionLike
model.scorePart.mensuralAndNeumes = notAllowed
model.sectionLike = section
model.sectionPart =
  model.endingLike
  | model.scoreDefLike
  | model.sectionLike
  | model.sectionPart.mensuralAndNeumes
  | model.staffDefLike
  | model.sectionPart.cmn
model.sectionPart.mensuralAndNeumes = model.staffLike
model.staffDefLike = staffDef
model.staffDefPart = model.keySigLike | model.meterSigLike | clef
model.staffGrpLike = staffGrp
model.staffLike = staff
model.staffLike_alternation = staff
model.staffLike_sequence = staff
model.staffLike_sequenceOptional = staff?
model.staffLike_sequenceOptionalRepeatable = staff*
model.staffLike_sequenceRepeatable = staff+
model.staffPart =
  model.layerLike | model.staffPart.mensuralAndNeumes | model.ossiaLike
model.staffPart.mensuralAndNeumes = notAllowed
model.sylLike = syl
model.textComponentLike =
  model.pLike | model.lgLike | model.listLike | model.quoteLike
model.textComponentLike_alternation =
  model.pLike_alternation
  | model.lgLike_alternation
  | model.listLike_alternation
  | model.quoteLike_alternation
model.textComponentLike_sequence =
  model.pLike_sequence,
  model.lgLike_sequence,
  model.listLike_sequence,
  model.quoteLike_sequence
model.textComponentLike_sequenceOptional =
  model.pLike_sequenceOptional?,
  model.lgLike_sequenceOptional?,
  model.listLike_sequenceOptional?,
  model.quoteLike_sequenceOptional?
model.textComponentLike_sequenceOptionalRepeatable =
  model.pLike_sequenceOptionalRepeatable*,
  model.lgLike_sequenceOptionalRepeatable*,
  model.listLike_sequenceOptionalRepeatable*,
  model.quoteLike_sequenceOptionalRepeatable*
model.textComponentLike_sequenceRepeatable =
  model.pLike_sequenceRepeatable+,
  model.lgLike_sequenceRepeatable+,
  model.listLike_sequenceRepeatable+,
  model.quoteLike_sequenceRepeatable+
model.textPhraseLike = model.pbLike | model.textPhraseLike.limited
model.textPhraseLike.limited =
  model.addressLike
  | model.annotLike
  | model.biblLike
  | model.dateLike
  | model.dimLike
  | model.editorialLike
  | model.identifierLike
  | model.lbLike
  | model.measurementLike
  | model.nameLike
  | model.relationLike
  | model.rendLike
  | model.titleLike
  | extent
  | term
  | model.addressPart
  | model.nameLike.label
  | model.qLike
  | seg
model.textPhraseLike.limited_alternation =
  model.addressLike_alternation
  | model.annotLike_alternation
  | model.biblLike_alternation
  | model.dateLike_alternation
  | model.dimLike_alternation
  | model.editorialLike_alternation
  | model.identifierLike_alternation
  | model.lbLike_alternation
  | model.measurementLike_alternation
  | model.nameLike_alternation
  | model.relationLike_alternation
  | model.rendLike_alternation
  | model.titleLike_alternation
  | extent
  | term
  | model.addressPart_alternation
  | model.nameLike.label_alternation
  | model.qLike_alternation
  | seg
model.textPhraseLike.limited_sequence =
  model.addressLike_sequence,
  model.annotLike_sequence,
  model.biblLike_sequence,
  model.dateLike_sequence,
  model.dimLike_sequence,
  model.editorialLike_sequence,
  model.identifierLike_sequence,
  model.lbLike_sequence,
  model.measurementLike_sequence,
  model.nameLike_sequence,
  model.relationLike_sequence,
  model.rendLike_sequence,
  model.titleLike_sequence,
  extent,
  term,
  model.addressPart_sequence,
  model.nameLike.label_sequence,
  model.qLike_sequence,
  seg
model.textPhraseLike.limited_sequenceOptional =
  model.addressLike_sequenceOptional?,
  model.annotLike_sequenceOptional?,
  model.biblLike_sequenceOptional?,
  model.dateLike_sequenceOptional?,
  model.dimLike_sequenceOptional?,
  model.editorialLike_sequenceOptional?,
  model.identifierLike_sequenceOptional?,
  model.lbLike_sequenceOptional?,
  model.measurementLike_sequenceOptional?,
  model.nameLike_sequenceOptional?,
  model.relationLike_sequenceOptional?,
  model.rendLike_sequenceOptional?,
  model.titleLike_sequenceOptional?,
  extent?,
  term?,
  model.addressPart_sequenceOptional?,
  model.nameLike.label_sequenceOptional?,
  model.qLike_sequenceOptional?,
  seg?
model.textPhraseLike.limited_sequenceOptionalRepeatable =
  model.addressLike_sequenceOptionalRepeatable*,
  model.annotLike_sequenceOptionalRepeatable*,
  model.biblLike_sequenceOptionalRepeatable*,
  model.dateLike_sequenceOptionalRepeatable*,
  model.dimLike_sequenceOptionalRepeatable*,
  model.editorialLike_sequenceOptionalRepeatable*,
  model.identifierLike_sequenceOptionalRepeatable*,
  model.lbLike_sequenceOptionalRepeatable*,
  model.measurementLike_sequenceOptionalRepeatable*,
  model.nameLike_sequenceOptionalRepeatable*,
  model.relationLike_sequenceOptionalRepeatable*,
  model.rendLike_sequenceOptionalRepeatable*,
  model.titleLike_sequenceOptionalRepeatable*,
  extent*,
  term*,
  model.addressPart_sequenceOptionalRepeatable*,
  model.nameLike.label_sequenceOptionalRepeatable*,
  model.qLike_sequenceOptionalRepeatable*,
  seg*
model.textPhraseLike.limited_sequenceRepeatable =
  model.addressLike_sequenceRepeatable+,
  model.annotLike_sequenceRepeatable+,
  model.biblLike_sequenceRepeatable+,
  model.dateLike_sequenceRepeatable+,
  model.dimLike_sequenceRepeatable+,
  model.editorialLike_sequenceRepeatable+,
  model.identifierLike_sequenceRepeatable+,
  model.lbLike_sequenceRepeatable+,
  model.measurementLike_sequenceRepeatable+,
  model.nameLike_sequenceRepeatable+,
  model.relationLike_sequenceRepeatable+,
  model.rendLike_sequenceRepeatable+,
  model.titleLike_sequenceRepeatable+,
  extent+,
  term+,
  model.addressPart_sequenceRepeatable+,
  model.nameLike.label_sequenceRepeatable+,
  model.qLike_sequenceRepeatable+,
  seg+
model.titleLike = title
model.titleLike_alternation = title
model.titleLike_sequence = title
model.titleLike_sequenceOptional = title?
model.titleLike_sequenceOptionalRepeatable = title*
model.titleLike_sequenceRepeatable = title+
model.titlePagePart =
  model.dateLike
  | model.editionLike
  | model.identifierLike
  | model.respLikePart
  | model.titleLike
  | availability
  | contents
  | perfMedium
  | plateNum
  | price
  | useRestrict
  | argument
  | epigraph
  | imprimatur
accid =
  
  ## (accidental)  Records a temporary alteration to the pitch of a note.
  element accid {
    empty, att.common.attributes, att.accid.log.attributes, empty
  }
address =
  
  ## Contains a postal address, for example of a publisher, an organization, or an individual.
  element address {
    (addrLine+ | model.addressPart+),
    att.common.attributes,
    att.lang.attributes,
    empty
  }
addrLine =
  
  ## (address line)  Single line of a postal address.
  element addrLine {
    (text
     | model.textPhraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.lang.attributes,
    empty
  }
annot =
  
  ## (annotation)  Provides a statement explaining the text or indicating the basis for an assertion.
  element annot {
    ((model.headLike*, model.textComponentLike*)
     | (text
        | model.editLike
        | model.textPhraseLike
        | model.transcriptionLike)*)
    >> sch:pattern [
         id = "wegaWorks-annot-Check_annot_data-constraint-rule-37"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:annot[@data]"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "ancestor::mei:notesStmt"
             "The @data attribute may only occur on an\x{a}" ~
             "            annotation within the notesStmt element."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.common.attributes,
    att.annot.log.attributes,
    att.audience.attributes,
    att.bibl.attributes,
    att.dataPointing.attributes,
    att.lang.attributes,
    att.plist.attributes,
    att.source.attributes,
    att.targetEval.attributes,
    empty
  }
arranger =
  
  ## A person or organization who transcribes a musical composition, usually for a different medium from that of the original; in an arrangement the musical substance remains essentially unchanged.
  element arranger {
    (text | model.textPhraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.evidence.attributes,
    att.lang.attributes,
    empty
  }
artic =
  
  ## (articulation)  An indication of how to play a note or chord.
  element artic {
    empty, att.common.attributes, att.artic.log.attributes, empty
  }
author =
  
  ## The name of the creator of the intellectual content of a non-musical, literary work.
  element author {
    (text | model.textPhraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.evidence.attributes,
    att.lang.attributes,
    empty
  }
bibl =
  
  ## (bibliographic reference)  Provides a loosely-structured bibliographic citation in which the sub-components may or may not be explicitly marked.
  element bibl {
    identifier?,
    title?,
    persName?,
    pubPlace?,
    date?,
    annot?,
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    att.pointing.attributes,
    empty
  }
body =
  
  ## Contains the whole of a single musical text, excluding any front or back matter.
  element body {
    (model.divLike | model.mdivLike)+,
    att.common.attributes,
    att.metadataPointing.attributes,
    empty
  }
chord =
  
  ## A simultaneous sounding of two or more notes in the same layer *with the same duration*.
  element chord {
    (model.chordPart
     | model.editLike
     | model.sylLike
     | model.transcriptionLike
     | model.verseLike)*,
    att.common.attributes,
    att.chord.log.attributes,
    empty
  }
clef =
  
  ## Indication of the exact location of a particular note on the staff and, therefore, the other notes as well.
  element clef {
    empty
    >> sch:pattern [
         id = "wegaWorks-clef-Clef_position_lines-constraint-rule-38"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:clef[ancestor::mei:staffDef[@lines]]"
           "\x{a}" ~
           "               "
           sch:let [
             name = "thisstaff"
             value = "ancestor::mei:staffDef/@n"
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "number(@line) <= number(ancestor::mei:staffDef[@n=$thisstaff and @lines][1]/@lines)"
             "The clef position must be less than or equal to the number of lines of an ancestor\x{a}" ~
             "            staff."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id = "wegaWorks-clef-Clef_position_nolines-constraint-rule-39"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:clef[ancestor::mei:staffDef[not(@lines)]]"
           "\x{a}" ~
           "               "
           sch:let [
             name = "thisstaff"
             value = "ancestor::mei:staffDef/@n"
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "number(@line) <= number(preceding::mei:staffDef[@n=$thisstaff and @lines][1]/@lines)"
             "The clef position must be less than or equal to the number of lines of a preceding\x{a}" ~
             "            staff."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.common.attributes,
    att.event.attributes,
    att.clef.log.attributes,
    empty
  }
composer =
  
  ## The name of the creator of the intellectual content of a musical work.
  element composer {
    (text | model.textPhraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.evidence.attributes,
    att.lang.attributes,
    empty
  }
contributor =
  
  ## Names of individuals, institutions, or organizations responsible for contributions to the intellectual content of a work, where the specialized elements for authors, editors, etc. do not suffice or do not apply.
  element contributor {
    ((text | model.textPhraseLike.limited)*)
    >> sch:pattern [
         id =
           "wegaWorks-contributor-check_contributor_role-constraint-rule-40"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:contributor"
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "not(matches(normalize-space(lower-case(@role)),               '(arranger|author|composer|contributor|editor|funder|librettist|lyricist|sponsor)'))"
             "The value of @role must not contain the name of another element available in this\x{a}" ~
             "            context."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.common.attributes,
    att.bibl.attributes,
    att.evidence.attributes,
    att.lang.attributes,
    
    ## Used to specify the contributor's function.
    attribute role { text }?,
    empty
  }
creation =
  
  ## Non-bibliographic details of the creation of an intellectual entity, in narrative form, such as the date, place, and circumstances of its composition. More detailed information may be captured within the history element.
  element creation {
    model.headLike*,
    (text | model.textPhraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.datable.attributes,
    att.lang.attributes,
    empty
  }
date =
  
  ## A string identifying a point in time or the time period between two such points.
  element date {
    (text | model.textPhraseLike)*,
    att.bibl.attributes,
    att.calendared.attributes,
    att.datable.attributes,
    att.edit.attributes,
    empty
  }
dir =
  [
    a:documentation [
      "(directive)  An instruction expressed as a combination of text and symbols  such as segno and coda symbols, fermatas over a bar line, etc., typically above, below, or between staves, but not on the staff  that is not encoded elsewhere in more specific elements, like "
      ns1:code [ "<tempo>" ]
      " or "
      ns1:code [ "<dynam>" ]
      "."
    ]
  ]
  element dir {
    ((text
      | model.textPhraseLike.limited
      | model.editLike
      | model.transcriptionLike)*)
    >> sch:pattern [
         id =
           "wegaWorks-dir-dir_start-type_attributes_required-constraint-rule-41"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:dir[not(ancestor::mei:syllable)]"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.common.attributes,
    att.lang.attributes,
    att.dir.log.attributes,
    empty
  }
dynam =
  
  ## (dynamic)  Indication of the volume of a note, phrase, or section of music.
  element dynam {
    ((text
      | model.textPhraseLike.limited
      | model.editLike
      | model.transcriptionLike)*)
    >> sch:pattern [
         id =
           "wegaWorks-dynam-dynam_start-type_attributes_required-constraint-rule-42"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:dynam"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             " Must have one of\x{a}" ~
             "            the attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id =
           "wegaWorks-dynam-dynam_end-type_attributes-constraint-rule-43"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:dynam[@val2]"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@dur or @dur.ges or @endid or @tstamp2"
             "When @val2 is present, either\x{a}" ~
             "            @dur, @dur.ges, @endid, or @tstamp2 must also be present."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.common.attributes,
    att.dynam.log.attributes,
    att.lang.attributes,
    empty
  }
edition =
  
  ## (edition designation)  A word or text phrase that indicates a difference in either content or form between the item being described and a related item previously issued by the same publisher/distributor (e.g. 2nd edition, version 2.0, etc.), or simultaneously issued by either the same publisher/distributor or another publisher/distributor (e.g. large print edition, British edition, etc.).
  element edition {
    (text | model.textPhraseLike.limited | respStmt)*,
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    empty
  }
event =
  
  ## Contains a free-text event description.
  element event {
    model.headLike*,
    ((model.eventPart | eventList)* | (model.pLike | \list)*),
    att.bibl.attributes,
    att.common.attributes,
    att.calendared.attributes,
    att.edit.attributes,
    att.lang.attributes,
    empty
  }
eventList =
  
  ## Contains historical information given as a sequence of significant past events.
  element eventList {
    model.headLike*,
    ((name
      | model.addressLike
      | model.dateLike
      | model.nameLike.agent
      | model.nameLike.geogName)?,
     (event | eventList))*,
    att.common.attributes,
    att.bibl.attributes,
    empty
  }
extent =
  
  ## Used to express size in terms other than physical dimensions, such as number of pages, records, bytes, physical components, etc.
  element extent {
    (text | model.textPhraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    att.quantity.attributes,
    empty
  }
group =
  
  ## Contains a composite musical text, grouping together a sequence of distinct musical texts (or groups of such musical texts) which are regarded as a unit for some purpose, for example, the collected works of a composer.
  element group {
    (music | group),
    (music | group)*,
    att.common.attributes,
    att.metadataPointing.attributes,
    empty
  }
identifier =
  
  ## An alpha-numeric string that establishes the identity of the described material.
  element identifier {
    (text
     | model.textPhraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.authorized.attributes,
    att.bibl.attributes,
    empty
  }
incip =
  
  ## (incipit)  The opening music and/or words of a musical or textual work.
  element incip {
    model.headLike*,
    tempo?,
    (clef)?,
    (perfRes | perfResList)?,
    (model.annotLike | model.scoreLike | incipCode | incipText)*,
    att.common.attributes,
    att.bibl.attributes,
    empty
  }
label =
  [
    a:documentation [
      'A container for document text that identifies the feature to which it is attached. For a "tool tip" or other generated label, use the '
      ns1:code [ "@label" ]
      " attribute."
    ]
  ]
  element label {
    (text
     | model.textPhraseLike.limited
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.lang.attributes,
    att.source.attributes,
    empty
  }
labelAbbr =
  
  ## A label on the pages following the first.
  element labelAbbr {
    (text
     | model.textPhraseLike.limited
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.lang.attributes,
    att.source.attributes,
    empty
  }
layer =
  
  ## An independent stream of events on a staff.
  element layer {
    (model.annotLike
     | model.editLike
     | model.layerPart
     | model.milestoneLike.music
     | model.transcriptionLike)*,
    att.basic.attributes,
    att.labelled.attributes,
    att.linking.attributes,
    att.metadataPointing.attributes,
    att.nInteger.attributes,
    att.responsibility.attributes,
    att.typed.attributes,
    att.layer.log.attributes,
    empty
  }
lb =
  
  ## (line beginning)  An empty formatting element that forces text to begin on a new line.
  element lb {
    empty, att.common.attributes, att.source.attributes, empty
  }
librettist =
  
  ## Person or organization who is a writer of the text of an opera, oratorio, etc.
  element librettist {
    (text | model.textPhraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.evidence.attributes,
    att.lang.attributes,
    empty
  }
lyricist =
  
  ## Person or organization who is a writer of the text of a song.
  element lyricist {
    (text | model.textPhraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.evidence.attributes,
    att.lang.attributes,
    empty
  }
mdiv =
  
  ## (musical division)  Contains a subdivision of the body of a musical text.
  element mdiv {
    ((model.scoreLike?, model.partsLike?) | model.mdivLike*),
    att.common.attributes,
    att.metadataPointing.attributes,
    att.mdiv.log.attributes,
    empty
  }
mei =
  
  ## contains a single MEI-conformant document, consisting of an MEI header and a musical text, either in isolation or as part of an meiCorpus element. 
  element mei {
    meiHead,
    music
    >> sch:pattern [
         id = "wegaWorks-mei-Check_staff-constraint-rule-44"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:*[@staff]"
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "every $i in tokenize(normalize-space(@staff), '\s+') satisfies $i=//mei:staffDef/@n"
             "The values in @staff must correspond to @n attribute of a staffDef\x{a}" ~
             "            element."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.meiVersion.attributes,
    att.responsibility.attributes,
    
    ## (identifier) supplies any form of identifier used to identify some object, such as a bibliographic item, a person, a title, an organization, etc. in a standardized way.
    attribute xml:id { key.work.pattern },
    empty
  }
music =
  
  ## Contains a single musical text of any kind, whether unitary or composite, for example, an etude, opera, song cycle, symphony, or anthology of piano solos.
  element music {
    model.resourceLike*,
    macro.musicPart,
    att.common.attributes,
    att.meiVersion.attributes,
    att.metadataPointing.attributes,
    empty
  }
name =
  
  ## Proper noun or noun phrase.
  element name {
    ((text
      | model.textPhraseLike
      | model.editLike
      | model.transcriptionLike)*)
    >> sch:pattern [
         id = "wegaWorks-name-nameParts-constraint-rule-45"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:name"
           "\x{a}" ~
           "               "
           sch:assert [
             role = "warning"
             test = "not(mei:geogName or mei:persName or mei:corpName)"
             "Recommended practice is to use name elements to capture sub-parts of a generic\x{a}" ~
             "            name."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.basic.attributes,
    att.bibl.attributes,
    att.classed.attributes,
    att.edit.attributes,
    att.labelled.attributes,
    att.lang.attributes,
    att.linking.attributes,
    att.name.attributes,
    att.nNumberLike.attributes,
    att.responsibility.attributes,
    
    ## Characterizes the name in some sense, using any convenient classification scheme or typology that employs single-token labels.
    ## Suggested values include: 1] person; 2] corporation; 3] location; 4] process; 5] style; 6] time
    attribute type {
      
      ## A personal name.
      "person"
      | 
        ## Name of a corporate body.
        "corporation"
      | 
        ## Name of a location.
        "location"
      | 
        ## Name of a process or software application.
        "process"
      | 
        ## Name of a musical style; i.e., form, genre, technique, etc.
        "style"
      | 
        ## Name of a period of time.
        "time"
      | xsd:NMTOKENS
    }?,
    empty
  }
note =
  
  ## A single pitched event. 
  element note {
    (model.noteModifierLike
     | model.verseLike
     | model.sylLike
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.note.log.attributes,
    empty
  }
p =
  
  ## (paragraph)  One or more text phrases that form a logical prose passage.
  element p {
    (text | model.paracontentPart)*,
    att.common.attributes,
    att.lang.attributes,
    att.metadataPointing.attributes,
    att.xy.attributes,
    empty
  }
physLoc =
  
  ## (physical location)  Groups information about the current physical location of a bibliographic item, such as the repository in which it is located and its shelf mark(s), and its previous locations.
  element physLoc {
    model.headLike*,
    (model.repositoryLike, model.identifierLike*)*,
    history?,
    att.common.attributes,
    att.bibl.attributes,
    empty
  }
publisher =
  
  ## Name of the organization responsible for the publication of a bibliographic item.
  element publisher {
    (text | model.textPhraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    empty
  }
pubPlace =
  
  ## (publication place)  Name of the place where a bibliographic item was published.
  element pubPlace {
    (text | model.textPhraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    empty
  }
relation =
  
  ## Describes a relationship or linkage amongst entities.
  element relation {
    empty
    >> sch:pattern [
         id = "wegaWorks-relation-FRBR_relation-constraint-rule-46"
         "\x{a}" ~
         "            "
         sch:rule [
           context =
             "mei:relationList/mei:relation[parent::mei:work or parent::mei:expression or                        parent::mei:source or parent::mei:item]"
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "matches(@rel, 'hasAbridgement') or             matches(@rel, 'hasAbridgement') or             matches(@rel, 'isAbridgementOf') or             matches(@rel, 'hasAdaptation') or             matches(@rel, 'isAdaptationOf') or             matches(@rel, 'hasAlternate') or             matches(@rel, 'isAlternateOf') or             matches(@rel, 'hasArrangement') or             matches(@rel, 'isArrangementOf') or             matches(@rel, 'hasComplement') or             matches(@rel, 'isComplementOf') or             matches(@rel, 'hasEmbodiment') or             matches(@rel, 'isEmbodimentOf') or             matches(@rel, 'hasExemplar') or             matches(@rel, 'isExemplarOf') or             matches(@rel, 'hasImitation') or             matches(@rel, 'isImitationOf') or             matches(@rel, 'hasPart') or             matches(@rel, 'isPartOf') or             matches(@rel, 'hasRealization') or             matches(@rel, 'isRealizationOf') or             matches(@rel, 'hasReconfiguration') or             matches(@rel, 'isReconfigurationOf') or             matches(@rel, 'hasReproduction') or             matches(@rel, 'isReproductionOf') or             matches(@rel, 'hasRevision') or             matches(@rel, 'isRevisionOf') or             matches(@rel, 'hasSuccessor') or             matches(@rel, 'isSuccessorOf') or             matches(@rel, 'hasSummarization') or             matches(@rel, 'isSummarizationOf') or             matches(@rel, 'hasSupplement') or             matches(@rel, 'isSupplementOf') or             matches(@rel, 'hasTransformation') or             matches(@rel, 'isTransformationOf') or             matches(@rel, 'hasTranslation') or             matches(@rel, 'isTranslationOf')"
             "Within work, expression, source, or item, the value of the rel attribute must match one\x{a}" ~
             "            of the following: hasAbridgement, isAbridgementOf, hasAdaptation, isAdaptationOf,\x{a}" ~
             "            hasAlternate, isAlternateOf, hasArrangement, isArrangementOf, hasComplement,\x{a}" ~
             "            isComplementOf, hasEmbodiment, isEmbodimentOf, hasExemplar, isExemplarOf, hasImitation,\x{a}" ~
             "            isImitationOf, hasPart, isPartOf, hasRealization, isRealizationOf, hasReconfiguration,\x{a}" ~
             "            isReconfigurationOf, hasReproduction, isReproductionOf, hasRevision, isRevisionOf,\x{a}" ~
             "            hasSuccessor, isSuccessorOf, hasSummarization, isSummarizationOf, hasSupplement,\x{a}" ~
             "            isSupplementOf, hasTransformation, isTransformationOf, hasTranslation,\x{a}" ~
             "            isTranslationOf"
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@target"
             "Within work, expression, source or item, the target attribute\x{a}" ~
             "            must be present."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.common.attributes,
    att.authorized.attributes,
    att.bibl.attributes,
    att.datable.attributes,
    att.evidence.attributes,
    att.plist.attributes,
    att.pointing.attributes,
    att.targetEval.attributes,
    
    ## Describes the relationship between the entities identified by the plist and target attributes.
    attribute rel { data.RELATIONSHIP },
    empty
  }
relationList =
  
  ## Gathers relation elements.
  element relationList {
    model.headLike*, model.relationLike*, att.common.attributes, empty
  }
rend =
  
  ## (render)  A formatting element indicating special visual rendering, e.g., bold or italicized, of a text word or phrase.
  element rend {
    (text
     | model.textPhraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.color.attributes,
    att.common.attributes,
    att.horizontalAlign.attributes,
    att.lang.attributes,
    att.textRendition.attributes,
    att.typography.attributes,
    att.verticalAlign.attributes,
    att.whitespace.attributes,
    
    ## A positive value for rotation rotates the text in a counter-clockwise fashion, while negative values produce clockwise rotation.
    attribute rotation { data.DEGREES }?,
    empty
  }
repository =
  
  ## Institution, agency, or individual which holds a bibliographic item.
  element repository {
    (text | model.textPhraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    att.name.attributes,
    empty
  }
respStmt =
  
  ## (responsibility statement)  Transcription of text that names one or more individuals, groups, or in rare cases, mechanical processes, responsible for creation, realization, production, funding, or distribution of the intellectual or artistic content.
  element respStmt {
    model.headLike*,
    ((name | model.nameLike.agent)*)
    >> sch:pattern [
         id = "wegaWorks-respStmt-check_respStmt-constraint-rule-47"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:respStmt[not(ancestor::mei:change)]"
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "(mei:resp and (mei:name or mei:corpName or mei:persName)) or              count(mei:*[@role]) = count(mei:*) and count(mei:*) > 0"
             role = "warning"
             "At least one element pair (a resp element and a name-like element) is\x{a}" ~
             "            recommended. Alternatively, each name-like element may have a @role\x{a}" ~
             "            attribute."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.common.attributes,
    att.bibl.attributes,
    empty
  }
rest =
  
  ## A non-sounding event found in the source being transcribed.
  element rest {
    ((model.editLike | model.transcriptionLike)*)
    >> sch:pattern [
         id = "wegaWorks-rest-Check_restline-constraint-rule-48"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:rest[@line]"
           "\x{a}" ~
           "               "
           sch:let [
             name = "thisstaff"
             value = "ancestor::mei:staff/@n"
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "number(@line) <= number(preceding::mei:staffDef[@n=$thisstaff and @lines][1]/@lines)"
             "The value of @line must be less than or equal to the number of lines on the\x{a}" ~
             "            staff."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.common.attributes,
    att.rest.log.attributes,
    empty
  }
score =
  
  ## Full score view of the musical content.
  element score {
    (model.annotLike
     | model.divLike
     | model.editLike
     | model.milestoneLike.music
     | model.relationLike
     | model.scoreDefLike
     | model.scorePart
     | model.staffDefLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.metadataPointing.attributes,
    att.score.log.attributes,
    empty
  }
scoreDef =
  
  ## (score definition)  Container for score meta-information.
  element scoreDef {
    model.keySigLike?,
    model.meterSigLike?,
    model.staffGrpLike?,
    att.common.attributes,
    att.scoreDef.log.attributes,
    empty
  }
section =
  
  ## Segment of music data.
  element section {
    ((model.annotLike
      | model.divLike
      | model.editLike
      | model.milestoneLike.music
      | model.relationLike
      | model.sectionPart
      | model.transcriptionLike)*)
    >> sch:pattern [
         id =
           "wegaWorks-section-Check_sectionexpansion-constraint-rule-49"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:section[mei:expansion]"
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "descendant::mei:section|descendant::mei:ending|descendant::mei:rdg"
             "A\x{a}" ~
             "            section containing an expansion element must have descendant section, ending, or rdg\x{a}" ~
             "            elements."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.common.attributes,
    att.metadataPointing.attributes,
    att.pointing.attributes,
    att.section.log.attributes,
    att.targetEval.attributes,
    empty
  }
space =
  
  ## A placeholder used to fill an incomplete measure, layer, etc. most often so that the combined duration of the events equals the number of beats in the measure.
  element space {
    empty, att.common.attributes, att.space.log.attributes, empty
  }
staff =
  
  ## A group of equidistant horizontal lines on which notes are placed in order to represent pitch or a grouping element for individual 'strands' of notes, rests, etc. that may or may not actually be rendered on staff lines; that is, both diastematic and non-diastematic signs.
  element staff {
    ((model.annotLike
      | model.editLike
      | model.milestoneLike.music
      | model.relationLike
      | model.staffDefLike
      | model.staffPart
      | model.transcriptionLike)*)
    >> sch:pattern [
         id = "wegaWorks-staff-checkStaff_n-constraint-rule-50"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:staff[@n]"
           "\x{a}" ~
           "               "
           sch:let [ name = "thisstaff" value = "@n" ]
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "preceding::mei:staffDef[@n=$thisstaff] or preceding::mei:staff[@n=$thisstaff]/mei:staffDef or mei:staffDef"
             "There must be a preceding staffDef with a matching value of @n, a preceding staff with\x{a}" ~
             "            a matching @n value containing a staffDef, or a staffDef child element."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.basic.attributes,
    att.labelled.attributes,
    att.linking.attributes,
    att.metadataPointing.attributes,
    att.nInteger.attributes,
    att.responsibility.attributes,
    att.typed.attributes,
    att.staff.log.attributes,
    empty
  }
staffDef =
  
  ## (staff definition)  Container for staff meta-information.
  element staffDef {
    model.labelLike*,
    ((model.instrDefLike | model.layerDefLike | model.staffDefPart)*)
    >> sch:pattern [
         id = "wegaWorks-staffDef-Check_staffDefn-constraint-rule-51"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:staffDef[not(ancestor::mei:staff)]"
           "\x{a}" ~
           "               "
           sch:let [ name = "thisstaff" value = "@n" ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@n"
             "StaffDef must have an n attribute."
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "@lines or preceding::mei:staffDef[@n=$thisstaff and @lines]"
             " Either\x{a}" ~
             "            @lines must be present or a preceding staffDef with the same value for @n and @lines\x{a}" ~
             "            must exist."
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "count(mei:clef) + count(mei:clefGrp) < 2"
             "Only one clef or clefGrp is\x{a}" ~
             "            permitted."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id =
           "wegaWorks-staffDef-Check_ancestor_staff-constraint-rule-52"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:staffDef[ancestor::mei:staff and @n]"
           "\x{a}" ~
           "               "
           sch:let [ name = "thisstaff" value = "@n" ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "ancestor::mei:staff/@n eq $thisstaff"
             "@n must have the same value as the\x{a}" ~
             "            current staff."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id =
           "wegaWorks-staffDef-Check_ancestor_staff_lines-constraint-rule-53"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:staffDef[ancestor::mei:staff and not(@n)]"
           "\x{a}" ~
           "               "
           sch:let [
             name = "thisstaff"
             value = "ancestor::mei:staff/@n"
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "@lines or preceding::mei:staffDef[@n=$thisstaff and @lines]"
             " Either\x{a}" ~
             "            @lines must be present or a preceding staffDef with matching @n value and @lines must\x{a}" ~
             "            exist."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id =
           "wegaWorks-staffDef-Check_clef_position_staffDef-constraint-rule-54"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:staffDef[@clef.line and @lines]"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "number(@clef.line) <= number(@lines)"
             "The clef position must be less\x{a}" ~
             "            than or equal to the number of lines on the staff."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id =
           "wegaWorks-staffDef-Check_clef_position_staffDef_nolines-constraint-rule-55"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:staffDef[@clef.line and not(@lines)]"
           "\x{a}" ~
           "               "
           sch:let [ name = "thisstaff" value = "@n" ]
           "\x{a}" ~
           "               "
           sch:let [
             name = "stafflines"
             value =
               "preceding::mei:staffDef[@n=$thisstaff and @lines][1]/@lines"
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "number(@clef.line) <= number($stafflines)"
             "The clef position must be\x{a}" ~
             "            less than or equal to the number of lines on the staff."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id =
           "wegaWorks-staffDef-Check_tab_strings_lines-constraint-rule-56"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:staffDef[@tab.strings and @lines]"
           "\x{a}" ~
           "               "
           sch:let [
             name = "countTokens"
             value =
               "count(tokenize(normalize-space(@tab.strings), '\s'))"
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "$countTokens = @lines"
             "The tab.strings attribute must have the same\x{a}" ~
             "            number of values as there are staff lines."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id =
           "wegaWorks-staffDef-Check_tab_strings_nolines-constraint-rule-57"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:staffDef[@tab.strings and not(@lines)]"
           "\x{a}" ~
           "               "
           sch:let [
             name = "countTokens"
             value =
               "count(tokenize(normalize-space(@tab.strings), '\s'))"
           ]
           "\x{a}" ~
           "               "
           sch:let [ name = "thisstaff" value = "@n" ]
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "$countTokens = preceding::mei:staffDef[@n=$thisstaff and @lines][1]/@lines"
             "The\x{a}" ~
             "            tab.strings attribute must have the same number of values as there are staff\x{a}" ~
             "            lines."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:staffDef[@lines.color and @lines]"
           "\x{a}" ~
           "               "
           sch:let [
             name = "countTokens"
             value =
               "count(tokenize(normalize-space(@lines.color), '\s'))"
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "$countTokens = 1 or $countTokens = @lines"
             "The lines.color attribute\x{a}" ~
             "              must have either 1) a single value or 2) the same number of values as there are staff\x{a}" ~
             "              lines."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:staffDef[@lines.color and not(@lines)]"
           "\x{a}" ~
           "               "
           sch:let [
             name = "countTokens"
             value =
               "count(tokenize(normalize-space(@lines.color), '\s'))"
           ]
           "\x{a}" ~
           "               "
           sch:let [ name = "thisstaff" value = "@n" ]
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "$countTokens = 1 or $countTokens = preceding::mei:staffDef[@n=$thisstaff and @lines][1]/@lines"
             "The lines.color attribute must have either 1) a single value or 2) the same number of\x{a}" ~
             "              values as there are staff lines."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "        "
       ]
    >> sch:pattern [
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:staffDef[@ppq][ancestor::mei:scoreDef[@ppq]]"
           "\x{a}" ~
           "               "
           sch:let [ name = "staffPPQ" value = "@ppq" ]
           "\x{a}" ~
           "               "
           sch:let [
             name = "scorePPQ"
             value = "ancestor::mei:scoreDef[@ppq][1]/@ppq"
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "($scorePPQ mod $staffPPQ) = 0"
             "The value of ppq must be a factor of\x{a}" ~
             "              the value of ppq on an ancestor scoreDef."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "        "
       ]
    >> sch:pattern [
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:staffDef[@ppq][preceding::mei:scoreDef[@ppq]]"
           "\x{a}" ~
           "               "
           sch:let [ name = "staffPPQ" value = "@ppq" ]
           "\x{a}" ~
           "               "
           sch:let [
             name = "scorePPQ"
             value = "preceding::mei:scoreDef[@ppq][1]/@ppq"
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "($scorePPQ mod $staffPPQ) = 0"
             "The value of ppq must be a factor of\x{a}" ~
             "              the value of ppq on a preceding scoreDef."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "        "
       ],
    att.basic.attributes,
    att.labelled.attributes,
    att.linking.attributes,
    att.metadataPointing.attributes,
    att.nInteger.attributes,
    att.responsibility.attributes,
    att.typed.attributes,
    att.staffDef.log.attributes,
    empty
  }
staffGrp =
  
  ## (staff group)  A group of bracketed or braced staves.
  element staffGrp {
    model.labelLike*,
    model.instrDefLike*,
    ((model.staffGrpLike | model.staffDefLike)+)
    >> sch:pattern [
         id =
           "wegaWorks-staffGrp-Check_staffGrp_unique_staff_n_values-constraint-rule-62"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:staffGrp"
           "\x{a}" ~
           "               "
           sch:let [
             name = "countstaves"
             value = "count(descendant::mei:staffDef)"
           ]
           "\x{a}" ~
           "               "
           sch:let [
             name = "countuniqstaves"
             value =
               "count(distinct-values(descendant::mei:staffDef/@n))"
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "$countstaves eq $countuniqstaves"
             "Each staffDef must have a unique value\x{a}" ~
             "            for the n attribute."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.common.attributes,
    att.metadataPointing.attributes,
    att.staffGrp.log.attributes,
    empty
  }
syl =
  
  ## (syllable)  Individual lyric syllable.
  element syl {
    (text
     | model.textPhraseLike.limited
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.lang.attributes,
    att.syl.log.attributes,
    empty
  }
tempo =
  
  ## Text and symbols descriptive of tempo, mood, or style, e.g., "allarg.", "a tempo", "cantabile", "Moderato", "=60", "Moderato  =60").
  element tempo {
    ((text
      | model.textPhraseLike.limited
      | model.editLike
      | model.transcriptionLike)*)
    >> sch:pattern [
         id =
           "wegaWorks-tempo-tempo_in_header_disallow_most_attrs-constraint-rule-63"
         "\x{a}" ~
         "            "
         sch:rule [
           context =
             "mei:tempo[not(ancestor::mei:score or ancestor::mei:part)]"
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "not(@*[name() != 'analog' and name() != 'class' and name() != 'label' and                name() != 'mm' and name() != 'mm.dots' and name() != 'translit' and                name() != 'type' and name() != 'mm.unit' and name() != 'n' and name() != 'xml:base' and                name() != 'xml:id' and name() != 'xml:lang'])"
             "Only analog, class, label, mm, mm.dots, mm.unit, n, translit, type, xml:base, xml:id,\x{a}" ~
             "            and xml:lang attributes are allowed when tempo is not a descendant of a score or\x{a}" ~
             "            part."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id =
           "wegaWorks-tempo-tempo_start-type_attributes_required-constraint-rule-64"
         "\x{a}" ~
         "            "
         sch:rule [
           context =
             "mei:tempo[not(ancestor::mei:syllable) and not(ancestor::mei:work) and not(ancestor::mei:expression) and not(count(ancestor::mei:*) = 0)]"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    att.tempo.log.attributes,
    empty
  }
term =
  
  ## Keyword or phrase which describes a resource.
  element term {
    ((text | model.textPhraseLike.limited)*)
    >> sch:pattern [
         id = "wegaWorks-term-Check_term_dataTarget-constraint-rule-65"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:term[@data]"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "ancestor::mei:classification"
             "The @data attribute may only occur on a\x{a}" ~
             "            term which is a descendant of a classification element."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.common.attributes,
    att.bibl.attributes,
    att.dataPointing.attributes,
    att.lang.attributes,
    empty
  }
title =
  
  ## Title of a bibliographic entity.
  element title {
    (text | lb | persName | name | add | del)+,
    att.edit.attributes,
    att.id.attribute.xmlid,
    att.bibl.attributes,
    att.classed.attributes,
    att.filing.attributes,
    att.lang.attributes,
    att.linking.attributes,
    att.nNumberLike.attributes,
    att.responsibility.attributes,
    
    ## Indicates the bibliographic level of the title.
    attribute level {
      
      ## Analyzed component, such as an article or chapter, within a larger bibliographic entity.
      "a"
      | 
        ## Collection. A group of items that were not originally published, distributed, or produced together.
        "c"
      | 
        ## Subunit of a collection, e.g. item, folder, box, archival series, subgroup, or subcollection.
        "d"
      | 
        ## Integrating resource, such as a continuously updated loose-leaf service or Web site.
        "i"
      | 
        ## Monograph.
        "m"
      | 
        ## Journal.
        "j"
      | 
        ## Series.
        "s"
      | 
        ## Unpublished (including theses and dissertations unless published by a commercial press).
        "u"
    }?,
    
    ## Characterizes the title in some sense, using any convenient classification scheme or typology that employs single-token labels.
    attribute type {
      
      ## marks a subtitle.
      "sub"
      | [
          a:documentation [
            "(alternative) marks an alternative title, most frequently translated (cf. "
            ns1:code [ "@xml:lang" ]
            ")."
          ]
        ]
        "alt"
      | 
        ## (number) marks a title of a musical division (e.g. scene, aria).
        "div"
      | 
        ## (uniform
        ##                                             title) 
        "uniform"
      | 
        ## marks a short title.
        "short"
      | 
        ## marks a title on the cover of a performance material.
        "cover"
      | 
        ## marks a title on the first page of the musical text etc.
        "firstPage"
    }?,
    empty
  }
titlePage =
  
  ## Contains a transcription of the title page of a text.
  element titlePage {
    model.headLike*,
    (model.imprintPart
     | model.milestoneLike.text
     | model.textComponentLike
     | model.titlePagePart
     | model.transcriptionLike)+,
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    empty
  }
att.recordType.attributes = att.recordType.attribute.recordtype
att.recordType.attribute.recordtype =
  
  ##
  attribute recordtype {
    
    ## Language material.
    "a"
    | 
      ## Notated music.
      "c"
    | 
      ## Manuscript notated music.
      "d"
    | 
      ## Non-manuscript cartographic material.
      "e"
    | 
      ## Manuscript cartographic material.
      "f"
    | 
      ## Projected medium.
      "g"
    | 
      ## Nonmusical sound recording.
      "i"
    | 
      ## Musical sound recording.
      "j"
    | 
      ## Two-dimensional nonprojectable graphic.
      "k"
    | 
      ## Computer file.
      "m"
    | 
      ## Kit.
      "o"
    | 
      ## Mixed materials.
      "p"
    | 
      ## Three-dimensional artifact or naturally occurring object.
      "r"
    | 
      ## Manuscript language material. 
      "t"
  }?
model.eventPart =
  model.addressLike
  | model.dateLike
  | name
  | model.nameLike.agent
  | model.nameLike.geogName
model.frontAndBackPart = titlePage
model.physDescPart =
  model.incipLike
  | extent
  | titlePage
  | condition
  | handList
  | inscription
  | physMedium
  | plateNum
  | watermark
model.pubStmtPart =
  model.addressLike
  | model.dateLike
  | model.identifierLike
  | publisher
  | pubPlace
  | respStmt
  | availability
model.workIdent = model.incipLike | tempo
model.workLike = work
componentList =
  
  ## Container for intellectual or physical component parts of a bibliographic entity.
  element componentList {
    model.headLike*,
    ((model.workLike* | model.expressionLike*)
     | (model.manifestationLike* | model.itemLike*))
    >> sch:pattern [
         id =
           "wegaWorks-componentList-checkComponentList-constraint-rule-66"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:componentList"
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "every $i in ./child::mei:*[not(local-name()='head')] satisfies              $i/local-name() eq ./parent::mei:*/local-name()"
             "Only child elements of the same name as the parent of the componentList are\x{a}" ~
             "            allowed."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id =
           "wegaWorks-componentList-checkComponents-constraint-rule-67"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:componentList[mei:*[@comptype]]"
           "\x{a}" ~
           "               "
           sch:assert [
             role = "warning"
             test =
               "count(mei:*[@comptype]) = count(mei:*[local-name() ne 'head'])"
             "When any child\x{a}" ~
             "            element has a comptype attribute, it is recommended that comptype appear on all child\x{a}" ~
             "            elements."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.common.attributes,
    empty
  }
altId =
  
  ## (alternative identifier)  May contain a bibliographic identifier that does not fit within the meiHead element's id attribute, for example because the identifier does not fit the definition of an XML id or because multiple identifiers are needed.
  element altId {
    text,
    att.id.attribute.xmlid,
    att.labelled.attribute.label,
    att.linking.attribute.copyof,
    att.linking.attribute.corresp,
    att.linking.attribute.follows,
    att.linking.attribute.next,
    att.linking.attribute.precedes,
    att.linking.attribute.prev,
    att.linking.attribute.sameas,
    att.linking.attribute.synch,
    att.nNumberLike.attribute.n,
    att.responsibility.attribute.resp,
    att.classed.attribute.class,
    
    ## Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
    ## Suggested values include: 1] gnd (Gemeinsame Normdatei); 2] opus; 3] WeGA (Werke)
    attribute type {
      list {
        (
         ## (Gemeinsame
         ##                                             Normdatei) marks information (ID and title) from the German authority file "Gemeinsamen Normdatei".
         "gnd"
         | 
           ## marks an opus number.
           "opus"
         | 
           ## (Werke) ID aus der WeGA
           "WeGA"
         | xsd:NMTOKEN)+
      }
    },
    empty
  }
availability =
  
  ## Groups elements that describe the availability of and access to a bibliographic item, including an MEI-encoded document.
  element availability {
    macro.availabilityPart,
    att.common.attributes,
    att.bibl.attributes,
    att.dataPointing.attributes,
    empty
  }
change =
  
  ## Individual change within the revision description.
  element change {
    respStmt?,
    changeDesc,
    (model.dateLike?)
    >> sch:pattern [
         id = "wegaWorks-change-check_change-constraint-rule-68"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:change"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@isodate or mei:date"
             "The date of the change must be recorded in an\x{a}" ~
             "            isodate attribute or date element."
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "@resp or mei:respStmt[mei:name or mei:corpName or mei:persName]"
             role = "warning"
             "It is recommended that the agent responsible for the change be recorded\x{a}" ~
             "            in a resp attribute or in a name, corpName, or persName element in the respStmt\x{a}" ~
             "            element."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.common.attributes,
    att.bibl.attributes,
    att.datable.attributes,
    empty
  }
changeDesc =
  
  ## (change description)  Description of a revision of the MEI file.
  element changeDesc {
    model.pLike+,
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    empty
  }
classification =
  
  ## Groups information which describes the nature or topic of an entity.
  element classification {
    model.headLike*,
    termList+,
    att.common.attributes,
    att.bibl.attributes,
    att.dataPointing.attributes,
    empty
  }
condition =
  
  ## The physical condition of an item, particularly any variances between the physical make-up of the item and that of other copies of the same item (e.g., missing pages or plates, brittleness, faded images, etc.).
  element condition {
    macro.struc-unstrucContent,
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    empty
  }
contentItem =
  
  ## Contains a single entry within a content description element.
  element contentItem {
    (text
     | model.textPhraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    empty
  }
contents =
  
  ## List of the material contained within a resource.
  element contents {
    model.headLike*,
    (model.pLike? | (label?, contentItem)+)
    >> sch:pattern [
         id =
           "wegaWorks-contents-checkContentsLabels-constraint-rule-69"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:contents[mei:label]"
           "\x{a}" ~
           "               "
           sch:assert [
             role = "warning"
             test = "count(mei:label) = count(mei:contentItem)"
             "When labels\x{a}" ~
             "            are used, usually each content item has one."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.common.attributes,
    att.bibl.attributes,
    att.pointing.attributes,
    empty
  }
editionStmt =
  
  ## (edition statement)  Container for meta-data pertaining to a particular edition of the material being described.
  element editionStmt {
    model.headLike*,
    (model.editionLike, (model.respLikePart | respStmt)*)+,
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    empty
  }
fileDesc =
  
  ## (file description)  Contains a full bibliographic description of the MEI file.
  element fileDesc {
    titleStmt,
    editionStmt?,
    extent?,
    pubStmt,
    seriesStmt?,
    notesStmt?,
    att.common.attributes,
    att.bibl.attributes,
    empty
  }
hand =
  
  ## Defines a distinct scribe or handwriting style.
  element hand {
    (text | model.textPhraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.evidence.attributes,
    att.lang.attributes,
    att.medium.attributes,
    
    ## Marks this hand as the first one of the document.
    attribute initial { data.BOOLEAN }?,
    empty
  }
handList =
  
  ## Container for one or more hand elements.
  element handList {
    model.headLike*,
    ((label?, hand)*)
    >> sch:pattern [
         id =
           "wegaWorks-handList-checkHandListLabels-constraint-rule-70"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:handList[mei:label]"
           "\x{a}" ~
           "               "
           sch:assert [
             role = "warning"
             test = "count(mei:label) = count(mei:hand)"
             "When labels are used,\x{a}" ~
             "            usually each hand has one."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.common.attributes,
    att.bibl.attributes,
    empty
  }
history =
  
  ## Provides a container for information about the history of a resource other than the circumstances of its creation.
  element history {
    model.headLike*,
    ((provenance | model.divLike | model.textComponentLike)*)
    >> sch:pattern [
         id = "wegaWorks-history-history_restriction-constraint-rule-71"
         "\x{a}" ~
         "            "
         sch:rule [
           context =
             "mei:history[parent::mei:work or parent::mei:expression]"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "not(mei:acquisition or mei:provenance)"
             "The acquisition and provenance\x{a}" ~
             "            elements are not permitted in the work or expression context."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.common.attributes,
    att.bibl.attributes,
    empty
  }
incipCode =
  
  ## Incipit coded in a non-XML, plain text format, such as Plaine & Easie Code.
  element incipCode {
    text
    >> sch:pattern [
         id =
           "wegaWorks-incipCode-Check_incipCode_form_mimetype-constraint-rule-72"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:incipCode"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@form or @mimetype"
             "incipCode must have a form or mimetype\x{a}" ~
             "            attribute."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.common.attributes,
    att.bibl.attributes,
    att.internetMedia.attributes,
    att.pointing.attributes,
    att.whitespace.attributes,
    
    ## Form of the encoded incipit.
    ## Suggested values include: 1] plaineAndEasie; 2] humdrumKern; 3] parsons
    attribute form {
      
      ## Plaine & Easie Code.
      "plaineAndEasie"
      | 
        ## Humdrum Kern format.
        "humdrumKern"
      | 
        ## Parsons code.
        "parsons"
      | xsd:NMTOKEN
    }?,
    empty
  }
incipText =
  
  ## Opening words of a musical composition.
  element incipText {
    model.headLike*,
    (model.pLike | model.lgLike)*,
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    att.pointing.attributes,
    att.internetMedia.attributes,
    empty
  }
inscription =
  
  ## An inscription added to an item, such as a bookplate, a note designating the item as a gift, and/or the author's signature.
  element inscription {
    macro.struc-unstrucContent,
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    empty
  }
language =
  
  ## Description of a language used in the document.
  element language {
    (text | model.textPhraseLike.limited)*,
    att.common.attributes,
    att.authorized.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    empty
  }
langUsage =
  
  ## (language usage)  Groups elements describing the languages, sub-languages, dialects, etc., represented within the encoded resource.
  element langUsage {
    model.headLike*,
    language+,
    att.common.attributes,
    att.bibl.attributes,
    att.dataPointing.attributes,
    empty
  }
meiHead =
  
  ## (MEI header)  Supplies the descriptive and declarative metadata prefixed to every MEI-conformant text.
  element meiHead {
    altId*,
    fileDesc,
    workList?,
    (revisionDesc?)
    >> sch:pattern [
         id = "wegaWorks-meiHead-check_meiHead_type-constraint-rule-73"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:meiHead[@type eq 'music']"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "ancestor::mei:mei"
             "The meiHead type attribute can have the value 'music'\x{a}" ~
             '            only when the document element is "mei".'
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:meiHead[@type eq 'corpus']"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "ancestor::mei:meiCorpus"
             "The meiHead type attribute can have the value\x{a}" ~
             """            'corpus' only when the document element is "meiCorpus"."""
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:meiHead[@type eq 'independent']"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "not(ancestor::mei:*)"
             "The meiHead type attribute can have the value\x{a}" ~
             """            'independent' only when the document element is "meiHead"."""
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.basic.attributes,
    att.bibl.attributes,
    att.labelled.attributes,
    att.lang.attributes,
    att.meiVersion.attributes,
    att.responsibility.attributes,
    
    ## Specifies the kind of document to which the header is attached, for example whether it is a corpus or individual text.
    attribute type {
      
      ## Header is attached to a music document.
      "music"
      | 
        ## Header is attached to a corpus.
        "corpus"
      | 
        ## Header is independent; i.e., not attached to either a music or a corpus document.
        "independent"
    }?,
    empty
  }
notesStmt =
  
  ## (notes statement) Collects any notes providing information about a text additional to that recorded in other parts of the bibliographic description.
  element notesStmt {
    model.headLike*,
    model.annotLike+,
    att.common.attributes,
    att.bibl.attributes,
    empty
  }
perfMedium =
  
  ## (performance medium)  Indicates the number and character of the performing forces used in a musical composition.
  element perfMedium {
    model.headLike*,
    perfResList?,
    model.annotLike*,
    att.common.attributes,
    att.authorized.attributes,
    att.bibl.attributes,
    empty
  }
perfRes =
  
  ## (performance resource)  Name of an instrument on which a performer plays, a performer's voice range, or a standard performing ensemble designation.
  element perfRes {
    (text | model.textPhraseLike.limited | perfRes)*,
    att.common.attributes,
    att.authorized.attributes,
    att.bibl.attributes,
    att.edit.attributes,
    att.lang.attributes,
    
    ## Indicates the number of performers.
    attribute count { xsd:positiveInteger }?,
    
    ## Marks this instrument or vocal part as a soloist. Do not use this attribute for a solo instrument which is not accompanied.
    attribute solo { data.BOOLEAN }?,
    empty
  }
perfResList =
  
  ## Several instrumental or vocal resources treated as a group.
  element perfResList {
    model.headLike*,
    (annot | perfRes | perfResList)*,
    att.common.attributes,
    att.authorized.attributes,
    att.bibl.attributes,
    att.edit.attributes,
    att.lang.attributes,
    
    ## Indicates the number of performers.
    attribute count { xsd:positiveInteger }?,
    empty
  }
physDesc =
  
  ## (physical description)  Container for information about the appearance, construction, or handling of physical materials, such as their dimension, quantity, color, style, and technique of creation.
  element physDesc {
    model.headLike*,
    model.pLike*,
    model.physDescPart*,
    att.common.attributes,
    att.bibl.attributes,
    empty
  }
physMedium =
  
  ## (physical medium)  Records the physical materials used in the source, such as ink and paper.
  element physMedium {
    macro.struc-unstrucContent,
    att.common.attributes,
    att.authorized.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    empty
  }
plateNum =
  
  ## (plate number)  Designation assigned to a resource by a music publisher, usually printed at the bottom of each page, and sometimes appearing also on the title page.
  element plateNum {
    macro.struc-unstrucContent,
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    empty
  }
price =
  
  ## The cost of access to a bibliographic item.
  element price {
    model.headLike*,
    (text | model.textPhraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    
    ## Numeric value capturing a cost. Can only be interpreted in combination with the currency attribute.
    attribute amount {
      xsd:decimal { pattern = "[0-9]+\.[0-9]{2}" }
    }?,
    
    ## Monetary unit.
    attribute currency { xsd:NMTOKEN }?,
    empty
  }
provenance =
  
  ## The record of ownership or custodianship of an item.
  element provenance {
    ((model.headLike*, (eventList | model.pLike)*)
     | (text | model.textPhraseLike.limited)*),
    att.common.attributes,
    att.bibl.attributes,
    att.datable.attributes,
    att.lang.attributes,
    empty
  }
pubStmt =
  
  ## (publication statement)  Container for information regarding the publication or distribution of a bibliographic item, including the publisher's name and address, the date of publication, and other relevant details.
  element pubStmt {
    model.headLike*,
    (model.pubStmtPart*),
    att.common.attributes,
    att.bibl.attributes,
    empty
  }
revisionDesc =
  
  ## (revision description)  Container for information about alterations that have been made to an MEI file.
  element revisionDesc {
    model.headLike*,
    change+,
    att.common.attributes,
    att.bibl.attributes,
    empty
  }
seriesStmt =
  
  ## (series statement)  Groups information about the series, if any, to which a publication belongs.
  element seriesStmt {
    model.headLike*,
    model.titleLike+,
    (model.respLikePart | respStmt)*,
    (model.identifierLike | contents | seriesStmt)*,
    att.common.attributes,
    att.bibl.attributes,
    empty
  }
source =
  
  ## A bibliographic description of a source used in the creation of the electronic file.
  element source {
    model.identifierLike*,
    titleStmt?,
    macro.bibldescPart,
    incip?,
    physDesc?,
    physLoc?,
    contents?,
    history?,
    langUsage?,
    notesStmt?,
    classification?,
    itemList?,
    (relationList?)
    >> sch:pattern [
         id = "wegaWorks-source-id-check-constraint-rule-76"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:source"
           "\x{a}" ~
           "                                    "
           sch:assert [
             test = "@xml:id or ancestor::mei:source"
             " Am\x{a}" ~
             "                                        Wurzelelement muss eine XML-ID angegeben sein. "
           ]
           "\x{a}" ~
           "                                "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id = "wegaWorks-source-check_source_target-constraint-rule-77"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:source/@target"
           "\x{a}" ~
           "               "
           sch:assert [
             role = "warning"
             test = "not(normalize-space(.) eq '')"
             "@target attribute should\x{a}" ~
             "            have content."
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             role = "warning"
             test =
               "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*[local-name()              eq 'source' or local-name() eq 'manifestation']/@xml:id or matches($i, '^([a-z]+://|\.{1,2}/)')"
             "Each value in @target should correspond to the @xml:id attribute of a source or\x{a}" ~
             "            manifestation element or be an external URI."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.basic.attribute.xmlbase,
    att.labelled.attribute.label,
    att.linking.attribute.copyof,
    att.linking.attribute.corresp,
    att.linking.attribute.follows,
    att.linking.attribute.next,
    att.linking.attribute.precedes,
    att.linking.attribute.prev,
    att.linking.attribute.sameas,
    att.linking.attribute.synch,
    att.nNumberLike.attribute.n,
    att.responsibility.attribute.resp,
    att.classed.attribute.class,
    att.authorized.attributes,
    att.bibl.attributes,
    att.dataPointing.attributes,
    att.pointing.attributes,
    att.recordType.attributes,
    att.targetEval.attributes,
    
    ## Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
    attribute xml:id { text }?,
    
    ## Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
    ## Suggested values include: 1] ms; 2] ms_score; 3] ms_piano_score; 4] ms_vocal_score; 5] ms_solo_part; 6] ms_choral_part; 7] ms_instrumental_part; 8] ms_script; 9] ms_prompt_book; 10] ms_textbook; 11] ms_inner_sheet; 12] ms_cut_sheet; 13] pr; 14] pr_score; 15] pr_piano_score; 16] pr_vocal_score; 17] pr_solo_part; 18] pr_choral_part; 19] pr_instrumental_part; 20] pr_script; 21] pr_prompt_book; 22] pr_textbook; 23] pr_inner_sheet; 24] pr_cut_sheet
    attribute type {
      list {
        (
         ## Manuscript
         "ms"
         | 
           ## Score in manuscript form
           "ms_score"
         | 
           ## Piano score in manuscript form
           "ms_piano_score"
         | 
           ## Vocal score in manuscript form
           "ms_vocal_score"
         | 
           ## Solo part in manuscript form
           "ms_solo_part"
         | 
           ## Choral part in manuscript form
           "ms_choral_part"
         | 
           ## Instrumental part in manuscript form
           "ms_instrumental_part"
         | 
           ## Handwritten script
           "ms_script"
         | 
           ## Handwritten prompt book
           "ms_prompt_book"
         | 
           ## Handwritten textbook
           "ms_textbook"
         | 
           ## Handwritten inner sheet
           "ms_inner_sheet"
         | 
           ## Handwritten cut sheet
           "ms_cut_sheet"
         | 
           ## Print
           "pr"
         | 
           ## Printed score
           "pr_score"
         | 
           ## Printed piano score
           "pr_piano_score"
         | 
           ## Printed vocal score
           "pr_vocal_score"
         | 
           ## Printed solo part
           "pr_solo_part"
         | 
           ## Printed choral part
           "pr_choral_part"
         | 
           ## Printed instrumental part
           "pr_instrumental_part"
         | 
           ## Printed script
           "pr_script"
         | 
           ## Printed prompt book
           "pr_prompt_book"
         | 
           ## Printed textbook
           "pr_textbook"
         | 
           ## Printed inner sheet
           "pr_inner_sheet"
         | 
           ## Printed cut sheet
           "pr_cut_sheet"
         | xsd:NMTOKEN)+
      }
    }?,
    empty
  }
termList =
  
  ## Collection of text phrases which describe a resource.
  element termList {
    model.headLike*,
    ((label?, term)*)
    >> sch:pattern [
         id =
           "wegaWorks-termList-checkTermListLabels-constraint-rule-78"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:termList[mei:label]"
           "\x{a}" ~
           "               "
           sch:assert [
             role = "warning"
             test = "count(mei:label) = count(mei:term)"
             "When labels are used,\x{a}" ~
             "            usually each term has one."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.common.attributes,
    att.bibl.attributes,
    att.pointing.attributes,
    empty
  }
titleStmt =
  
  ## (title statement)  Container for title and responsibility meta-data.
  element titleStmt {
    title+,
    respStmt?,
    att.id.attribute.xmlid,
    att.linking.attribute.copyof,
    att.linking.attribute.corresp,
    att.linking.attribute.follows,
    att.linking.attribute.next,
    att.linking.attribute.precedes,
    att.linking.attribute.prev,
    att.linking.attribute.sameas,
    att.linking.attribute.synch,
    att.responsibility.attribute.resp,
    att.typed.attribute.type,
    att.classed.attribute.class,
    att.bibl.attributes,
    empty
  }
useRestrict =
  
  ## (usage restrictions)  Container for information about the conditions that affect use of a bibliographic item after access has been granted.
  element useRestrict {
    macro.struc-unstrucContent,
    att.common.attributes,
    att.authorized.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    empty
  }
watermark =
  
  ## Contains a description of a watermark or similar device.
  element watermark {
    macro.struc-unstrucContent,
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    empty
  }
work =
  
  ## Provides a detailed description of a work  a distinct intellectual or artistic creation  specifically its history, language use, and high-level musical attributes (e.g., key, tempo, meter, medium of performance, and intended duration).
  element work {
    model.identifierLike*,
    title*,
    author*,
    composer*,
    librettist*,
    lyricist*,
    arranger*,
    contributor*,
    incip?,
    history?,
    langUsage?,
    perfMedium?,
    contents?,
    notesStmt?,
    classification?,
    bibl?,
    itemList?,
    expressionList?,
    (relationList?)
    >> sch:pattern [
         id = "wegaWorks-work-id-check-constraint-rule-79"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:source"
           "\x{a}" ~
           "                                    "
           sch:assert [
             test = "@xml:id or ancestor::mei:source"
             " Am\x{a}" ~
             "                                        Wurzelelement muss eine XML-ID angegeben sein. "
           ]
           "\x{a}" ~
           "                                "
         ]
         "\x{a}" ~
         "         "
       ],
    att.common.attributes,
    att.authorized.attributes,
    att.bibl.attributes,
    att.dataPointing.attributes,
    att.pointing.attributes,
    att.targetEval.attributes,
    empty
  }
workList =
  
  ## (work list)  Grouping mechanism for information describing non-bibliographic aspects of a text.
  element workList {
    model.headLike*, work+, att.common.attributes, empty
  }
model.addressPart = model.geogNamePart
model.addressPart_alternation = model.geogNamePart_alternation
model.addressPart_sequence = model.geogNamePart_sequence
model.addressPart_sequenceOptional =
  model.geogNamePart_sequenceOptional?
model.addressPart_sequenceOptionalRepeatable =
  model.geogNamePart_sequenceOptionalRepeatable*
model.addressPart_sequenceRepeatable =
  model.geogNamePart_sequenceRepeatable+
model.geogNamePart = notAllowed
model.geogNamePart_alternation = notAllowed
model.geogNamePart_sequence = empty
model.geogNamePart_sequenceOptional = empty
model.geogNamePart_sequenceOptionalRepeatable = empty
model.geogNamePart_sequenceRepeatable = notAllowed
model.nameLike.agent = corpName | persName
model.nameLike.agent_alternation = corpName | persName
model.nameLike.agent_sequence = corpName, persName
model.nameLike.agent_sequenceOptional = corpName?, persName?
model.nameLike.agent_sequenceOptionalRepeatable = corpName*, persName*
model.nameLike.agent_sequenceRepeatable = corpName+, persName+
model.nameLike.geogName = geogName
model.nameLike.geogName_alternation = geogName
model.nameLike.geogName_sequence = geogName
model.nameLike.geogName_sequenceOptional = geogName?
model.nameLike.geogName_sequenceOptionalRepeatable = geogName*
model.nameLike.geogName_sequenceRepeatable = geogName+
model.nameLike.label = periodName
model.nameLike.label_alternation = periodName
model.nameLike.label_sequence = periodName
model.nameLike.label_sequenceOptional = periodName?
model.nameLike.label_sequenceOptionalRepeatable = periodName*
model.nameLike.label_sequenceRepeatable = periodName+
model.nameLike.place = model.repositoryLike | model.nameLike.geogName
model.nameLike.place_alternation =
  model.repositoryLike_alternation | model.nameLike.geogName_alternation
model.nameLike.place_sequence =
  model.repositoryLike_sequence, model.nameLike.geogName_sequence
model.nameLike.place_sequenceOptional =
  model.repositoryLike_sequenceOptional?,
  model.nameLike.geogName_sequenceOptional?
model.nameLike.place_sequenceOptionalRepeatable =
  model.repositoryLike_sequenceOptionalRepeatable*,
  model.nameLike.geogName_sequenceOptionalRepeatable*
model.nameLike.place_sequenceRepeatable =
  model.repositoryLike_sequenceRepeatable+,
  model.nameLike.geogName_sequenceRepeatable+
model.persNamePart = notAllowed
corpName =
  
  ## (corporate name)  Identifies an organization or group of people that acts as a single entity.
  element corpName {
    (text
     | model.textPhraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.bibl.attributes,
    att.edit.attributes,
    att.lang.attributes,
    att.name.attributes,
    empty
  }
geogName =
  
  ## (geographic name)  The proper noun designation for a place, natural feature, or political jurisdiction.
  element geogName {
    (text
     | model.textPhraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.bibl.attributes,
    att.edit.attributes,
    att.lang.attributes,
    att.name.attributes,
    empty
  }
periodName =
  
  ## (period name)  A label that describes a period of time, such as 'Baroque' or '3rd Style period'.
  element periodName {
    (text
     | model.textPhraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.bibl.attributes,
    att.edit.attributes,
    att.lang.attributes,
    att.name.attributes,
    empty
  }
persName =
  
  ## (personal name) contains a proper noun or proper-noun phrase referring to a person, possibly including one or more of the person's forenames, surnames, honorifics, added names, etc.
  element persName {
    (text
     | model.textPhraseLike
     | model.editLike
     | model.transcriptionLike
     | model.persNamePart)*,
    att.id.attributes,
    att.authorized.attributes,
    att.bibl.attributes,
    [
      a:documentation [
        "The role or relation of this person with the text/score. Values are taken from the "
        ns1:a [
          href = "http://www.loc.gov/marc/relators/relaterm.html"
          "MARC\x{a}" ~
          "                                        Code List for Relators"
        ]
        "."
      ]
    ]
    attribute role { marcRelator.list }?,
    
    ## The Court Theatre ID of this person, e.g. "H000022" for Friedrich Elzner
    attribute dbkey { key.person.pattern }?,
    
    ## signifies the degree of certainty or precision of identifying this person.besagt den Grad der Gewissheit oder Przision der Identifikation der Person.
    attribute cert { data.CERTAINTY }?,
    empty
  }
att.beam.log.attributes =
  att.event.attributes, att.beamedWith.attributes
att.beamedWith.attributes = att.beamedWith.attribute.beam.with
att.beamedWith.attribute.beam.with =
  
  ## In the case of cross-staff beams, the beam.with attribute is used to indicate which staff the beam is connected to; that is, the staff above or the staff below.
  attribute beam.with { data.OTHERSTAFF }?
att.beaming.log.attributes =
  att.beaming.log.attribute.beam.group,
  att.beaming.log.attribute.beam.rests
att.beaming.log.attribute.beam.group =
  
  ## Provides an example of how automated beaming (including secondary beams) is to be performed.
  attribute beam.group { xsd:string }?
att.beaming.log.attribute.beam.rests =
  
  ## Indicates whether automatically-drawn beams should include rests shorter than a quarter note duration.
  attribute beam.rests { data.BOOLEAN }?
att.beamSpan.log.attributes =
  att.controlEvent.attributes,
  att.beamedWith.attributes,
  att.duration.additive.attributes,
  att.startEndId.attributes,
  att.timestamp2.logical.attributes
att.beatRpt.log.attributes =
  att.event.attributes, att.beatRpt.log.attribute.beatdef
att.beatRpt.log.attribute.beatdef =
  
  ## Indicates the performed duration represented by the beatRpt symbol; expressed in time signature denominator units.
  attribute beatdef {
    xsd:decimal { pattern = "\d+(\.\d+)?" }
  }?
att.bTrem.log.attributes =
  att.event.attributes,
  att.augmentDots.attributes,
  att.duration.logical.attributes,
  att.numbered.attributes,
  att.bTrem.log.attribute.form
att.bTrem.log.attribute.form =
  
  ## Indicates whether the tremolo is measured or unmeasured.
  attribute form {
    
    ## Measured tremolo.
    "meas"
    | 
      ## Unmeasured tremolo.
      "unmeas"
  }?
att.chord.log.cmn.attributes = att.graced.attributes
att.fermata.log.attributes =
  att.controlEvent.attributes, att.startEndId.attributes
att.fTrem.log.attributes =
  att.event.attributes,
  att.augmentDots.attributes,
  att.duration.logical.attributes,
  att.fTrem.log.attribute.form
att.fTrem.log.attribute.form =
  
  ## Describes the style of the tremolo.
  attribute form {
    
    ## Measured tremolo.
    "meas"
    | 
      ## Unmeasured tremolo.
      "unmeas"
  }?
att.graced.attributes =
  att.graced.attribute.grace, att.graced.attribute.grace.time
att.graced.attribute.grace =
  
  ## Marks a note or chord as a "grace" (without a definite performed duration) and records from which other note/chord it should "steal" time.
  attribute grace { data.GRACE }?
att.graced.attribute.grace.time =
  
  ## Records the amount of time to be "stolen" from a non-grace note/chord.
  attribute grace.time { data.PERCENT }?
att.hairpin.log.attributes =
  att.controlEvent.attributes,
  att.duration.additive.attributes,
  att.startEndId.attributes,
  att.timestamp2.logical.attributes,
  att.hairpin.log.attribute.form,
  att.hairpin.log.attribute.niente
att.hairpin.log.attribute.form =
  
  ## Captures the visual rendition and function of the hairpin; that is, whether it indicates an increase or a decrease in volume.
  attribute form {
    
    ## Crescendo; i.e., louder.
    "cres"
    | 
      ## Diminuendo; i.e., softer.
      "dim"
  }
att.hairpin.log.attribute.niente =
  
  ## Indicates that the hairpin starts from or ends in silence. Often rendered as a small circle attached to the closed end of the hairpin. See Gould, p. 108.
  attribute niente { data.BOOLEAN }?
att.halfmRpt.log.attributes =
  att.event.attributes, att.duration.logical.attributes
att.measure.log.attributes =
  att.meterConformance.bar.attributes,
  att.measure.log.attribute.left,
  att.measure.log.attribute.right
att.measure.log.attribute.left =
  
  ## Indicates the visual rendition of the left bar line. It is present here only for facilitation of translation from legacy encodings which use it. Usually, it can be safely ignored.
  attribute left { data.BARRENDITION }?
att.measure.log.attribute.right =
  
  ## Indicates the function of the right bar line and is structurally important.
  attribute right { data.BARRENDITION }?
att.mRest.log.attributes =
  att.cue.attributes,
  att.duration.additive.attributes,
  att.event.attributes
att.mRpt.log.attributes = att.event.attributes
att.note.log.cmn.attributes = att.graced.attributes
att.numbered.attributes = att.numbered.attribute.num
att.numbered.attribute.num =
  
  ## Records a number or count accompanying a notational feature.
  attribute num { xsd:positiveInteger }?
att.octave.log.attributes =
  att.controlEvent.attributes,
  att.duration.additive.attributes,
  att.octaveDisplacement.attributes,
  att.startEndId.attributes,
  att.timestamp2.logical.attributes,
  att.octave.log.attribute.coll
att.octave.log.attribute.coll =
  
  ## Indicates whether the octave displacement should be performed simultaneously with the written notes, i.e., "coll' ottava". Unlike other octave signs which are indicated by broken lines, coll' ottava typically uses an unbroken line or a series of longer broken lines, ending with a short vertical stroke. See Read, p. 47-48.
  attribute coll {
    
    ## Coll' ottava (with the octave).
    "coll"
  }?
att.rest.log.cmn.attributes = empty
att.scoreDef.log.cmn.attributes = att.beaming.log.attributes
att.slur.log.attributes =
  att.controlEvent.attributes,
  att.duration.additive.attributes,
  att.startEndId.attributes,
  att.timestamp2.logical.attributes
att.staffDef.log.cmn.attributes = att.beaming.log.attributes
att.tie.log.attributes =
  att.controlEvent.attributes,
  att.startEndId.attributes,
  att.timestamp2.logical.attributes
att.tuplet.log.attributes =
  att.beamedWith.attributes,
  att.duration.additive.attributes,
  att.duration.ratio.attributes,
  att.event.attributes,
  att.startEndId.attributes
att.tupletSpan.log.attributes =
  att.beamedWith.attributes,
  att.controlEvent.attributes,
  att.duration.additive.attributes,
  att.duration.ratio.attributes,
  att.startEndId.attributes,
  att.timestamp2.logical.attributes
model.controlEventLike.cmn =
  beamSpan
  | fermata
  | hairpin
  | octave
  | slur
  | tie
  | tupletSpan
  | model.ornamentLike.cmn
model.controlEventLike.cmn_alternation =
  beamSpan
  | fermata
  | hairpin
  | octave
  | slur
  | tie
  | tupletSpan
  | model.ornamentLike.cmn_alternation
model.controlEventLike.cmn_sequence =
  beamSpan,
  fermata,
  hairpin,
  octave,
  slur,
  tie,
  tupletSpan,
  model.ornamentLike.cmn_sequence
model.controlEventLike.cmn_sequenceOptional =
  beamSpan?,
  fermata?,
  hairpin?,
  octave?,
  slur?,
  tie?,
  tupletSpan?,
  model.ornamentLike.cmn_sequenceOptional?
model.controlEventLike.cmn_sequenceOptionalRepeatable =
  beamSpan*,
  fermata*,
  hairpin*,
  octave*,
  slur*,
  tie*,
  tupletSpan*,
  model.ornamentLike.cmn_sequenceOptionalRepeatable*
model.controlEventLike.cmn_sequenceRepeatable =
  beamSpan+,
  fermata+,
  hairpin+,
  octave+,
  slur+,
  tie+,
  tupletSpan+,
  model.ornamentLike.cmn_sequenceRepeatable+
model.eventLike.cmn = beam | beatRpt | bTrem | fTrem | halfmRpt | tuplet
model.eventLike.cmn_alternation =
  beam | beatRpt | bTrem | fTrem | halfmRpt | tuplet
model.eventLike.cmn_sequence =
  beam, beatRpt, bTrem, fTrem, halfmRpt, tuplet
model.eventLike.cmn_sequenceOptional =
  beam?, beatRpt?, bTrem?, fTrem?, halfmRpt?, tuplet?
model.eventLike.cmn_sequenceOptionalRepeatable =
  beam*, beatRpt*, bTrem*, fTrem*, halfmRpt*, tuplet*
model.eventLike.cmn_sequenceRepeatable =
  beam+, beatRpt+, bTrem+, fTrem+, halfmRpt+, tuplet+
model.eventLike.measureFilling = mRest | mRpt
model.eventLike.measureFilling_alternation = mRest | mRpt
model.eventLike.measureFilling_sequence = mRest, mRpt
model.eventLike.measureFilling_sequenceOptional = mRest?, mRpt?
model.eventLike.measureFilling_sequenceOptionalRepeatable =
  mRest*, mRpt*
model.eventLike.measureFilling_sequenceRepeatable = mRest+, mRpt+
model.layerPart.cmn =
  model.eventLike.cmn | model.eventLike.measureFilling
model.measureLike = measure
model.measureLike_alternation = measure
model.measureLike_sequence = measure
model.measureLike_sequenceOptional = measure?
model.measureLike_sequenceOptionalRepeatable = measure*
model.measureLike_sequenceRepeatable = measure+
model.measurePart =
  model.controlEventLike
  | model.staffLike
  | model.controlEventLike.cmn
  | model.ossiaLike
model.ossiaLike = notAllowed
model.sectionPart.cmn = model.measureLike
beam =
  
  ## A container for a series of explicitly beamed events that begins and ends entirely within a measure.
  element beam {
    ((model.eventLike
      | model.eventLike.cmn
      | model.editLike
      | model.transcriptionLike)*)
    >> sch:pattern [
         id =
           "wegaWorks-beam-When_not_copyof_beam_content-constraint-rule-80"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:beam[not(@copyof)]"
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "count(descendant::*[local-name()='note' or local-name()='rest' or               local-name()='chord' or local-name()='space']) > 1"
             "A beam without a copyof attribute must have at least 2 note, rest, chord, or space\x{a}" ~
             "            descendants."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.common.attributes,
    att.beam.log.attributes,
    empty
  }
beamSpan =
  
  ## (beam span)  Alternative element for explicitly encoding beams, particularly those which extend across bar lines.
  element beamSpan {
    empty
    >> sch:pattern [
         id =
           "wegaWorks-beamSpan-beamspan_start-_and_end-type_attributes_required-constraint-rule-81"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:beamSpan"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@dur or @dur.ges or @endid or @tstamp2"
             "Must have one of the attributes:\x{a}" ~
             "            dur, dur.ges, endid, or tstamp2."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.common.attributes,
    att.beamSpan.log.attributes,
    empty
  }
beatRpt =
  
  ## (beat repeat)  An indication that material on a preceding beat should be repeated.
  element beatRpt {
    empty,
    att.common.attributes,
    att.beatRpt.log.attributes,
    att.plist.attributes,
    att.targetEval.attributes,
    empty
  }
bTrem =
  
  ## (bowed tremolo)  A rapid alternation on a single pitch or chord.
  element bTrem {
    (chord | note),
    att.common.attributes,
    att.bTrem.log.attributes,
    empty
  }
fermata =
  
  ## An indication placed over a note or rest to indicate that it should be held longer than its written value. May also occur over a bar line to indicate the end of a phrase or section. Sometimes called a 'hold' or 'pause'.
  element fermata {
    empty
    >> sch:pattern [
         id =
           "wegaWorks-fermata-fermata_start-type_attributes_required-constraint-rule-82"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:fermata"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.common.attributes,
    att.fermata.log.attributes,
    empty
  }
fTrem =
  
  ## (fingered tremolo)  A rapid alternation between a pair of notes (or chords or perhaps between a note and a chord) that are (usually) farther apart than a major second.
  element fTrem {
    ((chord, (chord | note))
     | (note, (chord | note))),
    att.common.attributes,
    att.fTrem.log.attributes,
    empty
  }
hairpin =
  
  ## Indicates continuous dynamics expressed on the score as wedge-shaped graphics, e.g. < and >.
  element hairpin {
    empty
    >> sch:pattern [
         id =
           "wegaWorks-hairpin-hairpin_start-_and_end-type_attributes_required-constraint-rule-83"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:hairpin"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@dur or @dur.ges or @endid or @tstamp2"
             "Must have one of the attributes:\x{a}" ~
             "            dur, dur.ges, endid, or tstamp2."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.common.attributes,
    att.hairpin.log.attributes,
    empty
  }
halfmRpt =
  
  ## (half-measure repeat)  A half-measure repeat in any meter.
  element halfmRpt {
    empty, att.common.attributes, att.halfmRpt.log.attributes, empty
  }
measure =
  
  ## Unit of musical time consisting of a fixed number of note values of a given type, as determined by the prevailing meter, and delimited in musical notation by bar lines.
  element measure {
    (model.annotLike
     | model.editLike
     | model.measurePart
     | model.milestoneLike.music
     | model.relationLike
     | model.staffDefLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.metadataPointing.attributes,
    att.pointing.attributes,
    att.measure.log.attributes,
    att.targetEval.attributes,
    empty
  }
mRest =
  
  ## (measure rest)  Complete measure rest in any meter. 
  element mRest {
    empty, att.common.attributes, att.mRest.log.attributes, empty
  }
mRpt =
  
  ## (measure repeat)  An indication that the previous measure should be repeated.
  element mRpt {
    empty, att.common.attributes, att.mRpt.log.attributes, empty
  }
octave =
  
  ## An indication that a passage should be performed one or more octaves above or below its written pitch.
  element octave {
    ((text | model.textPhraseLike.limited)*)
    >> sch:pattern [
         id =
           "wegaWorks-octave-octave_start-_and_end-type_attributes_required-constraint-rule-84"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:octave"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@dur or @dur.ges or @endid or @tstamp2"
             "Must have one of the attributes:\x{a}" ~
             "            dur, dur.ges, endid, or tstamp2."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.common.attributes,
    att.octave.log.attributes,
    empty
  }
slur =
  
  ## Indication of 1) a "unified melodic idea" or 2) performance technique.
  [
    sch:pattern [
      id =
        "wegaWorks-slur-slur_start-_and_end-type_attributes_required-constraint-rule-85"
      "\x{a}" ~
      "            "
      sch:rule [
        context = "mei:slur"
        "\x{a}" ~
        "               "
        sch:assert [
          test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
          "Must have one of the\x{a}" ~
          "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
        ]
        "\x{a}" ~
        "               "
        sch:assert [
          test = "@dur or @dur.ges or @endid or @tstamp2"
          "Must have one of the attributes:\x{a}" ~
          "            dur, dur.ges, endid, or tstamp2."
        ]
        "\x{a}" ~
        "            "
      ]
      "\x{a}" ~
      "         "
    ]
    sch:pattern [
      id = "wegaWorks-slur-slur_containing_curve-constraint-rule-86"
      "\x{a}" ~
      "            "
      sch:rule [
        context =
          "mei:slur[mei:curve[@bezier or @bulge or @curvedir or @lform or @lwidth or              @ho or @startho or @endho or @to or @startto or @endto or @vo or @startvo or @endvo or              @x or @y or @x2 or @y2]]"
        "\x{a}" ~
        "               "
        sch:assert [
          test =
            "not(@bezier or @bulge or @curvedir or @lform or @lwidth or @ho or @startho or                @endho or @to or @startto or @endto or @vo or @startvo or @endvo or @x or @y or @x2 or @y2)"
          role = "warning"
          "The visual attributes of the slur (@bezier, @bulge, @curvedir, @lform,\x{a}" ~
          "            @lwidth, @ho, @startho, @endho, @to, @startto, @endto, @vo, @startvo, @endvo, @x, @y,\x{a}" ~
          "            @x2, and @y2) will be overridden by visual attributes of the contained curve\x{a}" ~
          "            elements."
        ]
        "\x{a}" ~
        "            "
      ]
      "\x{a}" ~
      "         "
    ]
  ]
  element slur { att.common.attributes, att.slur.log.attributes, empty }
tie =
  
  ## An indication that two notes of the same pitch form a single note with their combined rhythmic values.
  [
    sch:pattern [
      id =
        "wegaWorks-tie-tie_start-_and_end-type_attributes_required-constraint-rule-87"
      "\x{a}" ~
      "            "
      sch:rule [
        context = "mei:tie"
        "\x{a}" ~
        "               "
        sch:assert [
          test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
          "Must have one of the\x{a}" ~
          "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
        ]
        "\x{a}" ~
        "               "
        sch:assert [
          test = "@dur or @dur.ges or @endid or @tstamp2"
          "Must have one of the attributes:\x{a}" ~
          "            dur, dur.ges, endid, or tstamp2."
        ]
        "\x{a}" ~
        "            "
      ]
      "\x{a}" ~
      "         "
    ]
    sch:pattern [
      id = "wegaWorks-tie-tie_containing_curve-constraint-rule-88"
      "\x{a}" ~
      "            "
      sch:rule [
        context =
          "mei:tie[mei:curve[@bezier or @bulge or @curvedir or @lform or @lwidth or              @ho or @startho or @endho or @to or @startto or @endto or @vo or @startvo or              @endvo or @x or @y or @x2 or @y2]]"
        "\x{a}" ~
        "               "
        sch:assert [
          test =
            "not(@bezier or @bulge or @curvedir or @lform or @lwidth or @ho or @startho or                @endho or @to or @startto or @endto or @vo or @startvo or @endvo or @x or @y or @x2 or @y2)"
          role = "warning"
          "The visual attributes of the tie (@bezier, @bulge, @curvedir, @lform,\x{a}" ~
          "            @lwidth, @ho, @startho, @endho, @to, @startto, @endto, @vo, @startvo, @endvo, @x, @y,\x{a}" ~
          "            @x2, and @y2) will be overridden by visual attributes of the contained curve\x{a}" ~
          "            elements."
        ]
        "\x{a}" ~
        "            "
      ]
      "\x{a}" ~
      "         "
    ]
  ]
  element tie { att.common.attributes, att.tie.log.attributes, empty }
tuplet =
  
  ## A group of notes with "irregular" (sometimes called "irrational") rhythmic values, for example, three notes in the time normally occupied by two or nine in the time of five.
  element tuplet {
    ((model.editLike
      | model.eventLike
      | model.eventLike.cmn
      | model.transcriptionLike)*)
    >> sch:pattern [
         id =
           "wegaWorks-tuplet-When_not_copyof_tuplet_content-constraint-rule-89"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:tuplet[not(@copyof)]"
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "count(descendant::*[local-name()='note' or local-name()='rest' or               local-name()='chord']) > 1"
             "A tuplet without a copyof attribute must have at least 2 note, rest, or chord\x{a}" ~
             "            descendants."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.common.attributes,
    att.tuplet.log.attributes,
    empty
  }
tupletSpan =
  
  ## (tuplet span)  Alternative element for encoding tuplets, especially useful for tuplets that extend across bar lines.
  element tupletSpan {
    empty
    >> sch:pattern [
         id =
           "wegaWorks-tupletSpan-tupletSpan_start-_and_end-type_attributes_required-constraint-rule-90"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:tupletSpan"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@dur or @dur.ges or @endid or @tstamp2"
             "Must have one of the attributes:\x{a}" ~
             "            dur, dur.ges, endid, or tstamp2."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.common.attributes,
    att.tupletSpan.log.attributes,
    empty
  }
att.ornamentAccid.attributes =
  att.ornamentAccid.attribute.accidupper,
  att.ornamentAccid.attribute.accidlower
att.ornamentAccid.attribute.accidupper =
  
  ## Records the written accidental associated with an upper neighboring note.
  attribute accidupper { data.ACCIDENTAL.WRITTEN }?
att.ornamentAccid.attribute.accidlower =
  
  ## Records the written accidental associated with a lower neighboring note.
  attribute accidlower { data.ACCIDENTAL.WRITTEN }?
att.trill.log.attributes =
  att.controlEvent.attributes,
  att.duration.additive.attributes,
  att.ornamentAccid.attributes,
  att.startEndId.attributes,
  att.timestamp2.logical.attributes
att.turn.log.attributes =
  att.controlEvent.attributes,
  att.ornamentAccid.attributes,
  att.startId.attributes,
  att.turn.log.attribute.delayed,
  att.turn.log.attribute.form
att.turn.log.attribute.delayed =
  
  ## When set to 'true', the turn begins on the second half of the beat.
  attribute delayed { data.BOOLEAN }?
att.turn.log.attribute.form =
  [
    a:documentation [
      "Records meaning; i.e., intended performance, of the turn. The "
      ns1:code [ "@altsym" ]
      ", "
      ns1:code [ "@glyph.name" ]
      ", or "
      ns1:code [ "@glyph.num" ]
      " attributes may be used to specify the appropriate symbol."
    ]
  ]
  attribute form {
    
    ## Begins on the note below the written note.
    "lower"
    | 
      ## Begins on the note above the written note.
      "upper"
  }?
model.ornamentLike.cmn = trill | turn
model.ornamentLike.cmn_alternation = trill | turn
model.ornamentLike.cmn_sequence = trill, turn
model.ornamentLike.cmn_sequenceOptional = trill?, turn?
model.ornamentLike.cmn_sequenceOptionalRepeatable = trill*, turn*
model.ornamentLike.cmn_sequenceRepeatable = trill+, turn+
trill =
  
  ## Rapid alternation of a note with another (usually at the interval of a second above).
  element trill {
    empty
    >> sch:pattern [
         id =
           "wegaWorks-trill-trill_start-type_attributes_required-constraint-rule-91"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:trill"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.common.attributes,
    att.trill.log.attributes,
    empty
  }
turn =
  
  ## An ornament consisting of four notes  the upper neighbor of the written note, the written note, the lower neighbor, and the written note.
  element turn {
    empty
    >> sch:pattern [
         id =
           "wegaWorks-turn-turn_start-type_attributes_required-constraint-rule-92"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:turn"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.common.attributes,
    att.turn.log.attributes,
    empty
  }
att.verse.log.attributes = empty
model.verseLike = verse
model.verseLike_alternation = verse
model.verseLike_sequence = verse
model.verseLike_sequenceOptional = verse?
model.verseLike_sequenceOptionalRepeatable = verse*
model.verseLike_sequenceRepeatable = verse+
verse =
  
  ## Division of a poem or song lyrics, sometimes having a fixed length, meter or rhyme scheme; a stanza.
  element verse {
    label*,
    labelAbbr*,
    (dir | dynam | tempo | space)*,
    (model.sylLike)+,
    model.lbLike*,
    att.common.attributes,
    att.lang.attributes,
    att.verse.log.attributes,
    empty
  }
model.backLike = back
model.divLike = notAllowed
model.frontLike = front
model.lgLike = notAllowed
model.lgLike_alternation = notAllowed
model.lgLike_sequence = empty
model.lgLike_sequenceOptional = empty
model.lgLike_sequenceOptionalRepeatable = empty
model.lgLike_sequenceRepeatable = notAllowed
model.listLike = eventList | \list
model.listLike_alternation = eventList | \list
model.listLike_sequence = eventList, \list
model.listLike_sequenceOptional = eventList?, \list?
model.listLike_sequenceOptionalRepeatable = eventList*, \list*
model.listLike_sequenceRepeatable = eventList+, \list+
model.qLike = q
model.qLike_alternation = q
model.qLike_sequence = q
model.qLike_sequenceOptional = q?
model.qLike_sequenceOptionalRepeatable = q*
model.qLike_sequenceRepeatable = q+
model.quoteLike = quote
model.quoteLike_alternation = quote
model.quoteLike_sequence = quote
model.quoteLike_sequenceOptional = quote?
model.quoteLike_sequenceOptionalRepeatable = quote*
model.quoteLike_sequenceRepeatable = quote+
argument =
  
  ## Contains a formal list or prose description of topics addressed.
  element argument {
    (model.headLike | model.milestoneLike.text)*,
    ((model.textComponentLike), model.milestoneLike.text*)*,
    att.common.attributes,
    att.lang.attributes,
    att.metadataPointing.attributes,
    empty
  }
back =
  
  ## (back matter)  Contains any appendixes, advertisements, indexes, etc. following the main body of a musical text.
  element back {
    (model.divLike
     | model.frontAndBackPart
     | model.milestoneLike.text
     | model.relationLike)*,
    att.common.attributes,
    att.lang.attributes,
    att.metadataPointing.attributes,
    empty
  }
epigraph =
  
  ## Contains a quotation, anonymous or attributed, appearing on a title page.
  element epigraph {
    (text | model.paracontentPart | p)*,
    att.common.attributes,
    att.lang.attributes,
    att.metadataPointing.attributes,
    empty
  }
front =
  
  ## (front matter)  Bundles prefatory text found before the start of the musical text.
  element front {
    (model.divLike
     | model.frontAndBackPart
     | model.milestoneLike.text
     | model.relationLike)*,
    att.common.attributes,
    att.lang.attributes,
    att.metadataPointing.attributes,
    empty
  }
imprimatur =
  
  ## Contains a formal statement authorizing the publication of a work, sometimes required to appear on a title page or its verso.
  element imprimatur {
    (text | model.paracontentPart)*,
    att.common.attributes,
    att.lang.attributes,
    att.metadataPointing.attributes,
    empty
  }
li =
  [
    a:documentation [
      "(list item)  Single item in a "
      ns1:code [ "<list>" ]
      "."
    ]
  ]
  element li {
    (text
     | model.textComponentLike
     | model.textPhraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.lang.attributes,
    empty
  }
\list =
  
  ## A formatting element that contains a series of items separated from one another and arranged in a linear, often vertical, sequence.
  element list {
    model.headLike*,
    ((label?, li)*)
    >> sch:pattern [
         id = "wegaWorks-list-list_type_constraint-constraint-rule-93"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:list[contains(@type,'gloss')]"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "count(mei:label) = count(mei:li)"
             'In a list of type "gloss" all items\x{a}' ~
             "            must be immediately preceded by a label."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.basic.attributes,
    att.classed.attributes,
    att.labelled.attributes,
    att.lang.attributes,
    att.linking.attributes,
    att.nNumberLike.attributes,
    att.responsibility.attributes,
    att.xy.attributes,
    [
      a:documentation [
        'Used to indicate the format of a list. In a "simple" list, '
        ns1:code [ "<li>" ]
        ' elements are not numbered or bulleted. In a "marked" list, the sequence of the list items is not critical, and a bullet, box, dash, or other character is displayed at the start of each '
        ns1:code [ "<item>" ]
        '. In an "ordered" list, the sequence of the items is important, and each '
        ns1:code [ "<li>" ]
        " is lettered or numbered. Style sheet functions should be used to specify the mark or numeration system for each "
        ns1:code [ "<li>" ]
        "."
      ]
    ]
    attribute form {
      
      ## Items are not numbered or bulleted.
      "simple"
      | 
        ## Bullet, box, dash, or other character is displayed before each item.
        "marked"
      | 
        ## Each item is numbered or lettered.
        "ordered"
    }?,
    
    ## Captures the nature of the content of a list.
    ## Suggested values include: 1] gloss; 2] index; 3] instructions; 4] litany; 5] syllogism
    attribute type {
      
      ## Each list item glosses some term or concept, which is given by a label element preceding the list item.
      "gloss"
      | 
        ## Each list item is an entry in an index such as the alphabetical topical index at the back of a print volume.
        "index"
      | 
        ## Each list item is a step in a sequence of instructions, as in a recipe.
        "instructions"
      | 
        ## Each list item is one of a sequence of petitions, supplications or invocations, typically in a religious ritual.
        "litany"
      | 
        ## Each list item is part of an argument consisting of two or more propositions and a final conclusion derived from them.
        "syllogism"
      | xsd:NMTOKENS
    }?,
    empty
  }
q =
  [
    a:documentation [
      "(quoted)  Contains material which is distinguished from the surrounding phrase-level text using quotation marks or a similar method. Use "
      ns1:code [ "<quote>" ]
      " for block-level quotations."
    ]
  ]
  element q {
    (text | model.textPhraseLike)*,
    att.basic.attributes,
    att.classed.attributes,
    att.labelled.attributes,
    att.lang.attributes,
    att.linking.attributes,
    att.nNumberLike.attributes,
    att.responsibility.attributes,
    
    ## 
    ## Suggested values include: 1] spoken; 2] thought; 3] written; 4] soCalled; 5] foreign; 6] distinct; 7] term; 8] emph; 9] mentioned
    attribute type {
      list {
        (
         ## Representation of speech.
         "spoken"
         | 
           ## Representation of thought, e.g. internal monologue.
           "thought"
         | 
           ## Quotation from a written source.
           "written"
         | 
           ## Authorial distance.
           "soCalled"
         | 
           ## Linguistically distinct.
           "foreign"
         | 
           ## Linguistically distinct.
           "distinct"
         | 
           ## Technical term.
           "term"
         | 
           ## Rhetorically emphasized.
           "emph"
         | 
           ## Refering to itself, not its normal referent.
           "mentioned"
         | xsd:NMTOKEN)+
      }
    }?,
    empty
  }
quote =
  
  ## (quoted material)  Contains a paragraph-like block of text attributed to an external source, normally set off from the surrounding text by spacing or other typographic distinction.
  element quote {
    (text | model.paracontentPart | model.pLike)*,
    att.common.attributes,
    att.lang.attributes,
    att.xy.attributes,
    empty
  }
seg =
  
  ## (arbitrary segment) represents any segmentation of text below the "text component" level.
  element seg {
    (text
     | model.editLike
     | model.sylLike
     | model.textPhraseLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.lang.attributes,
    empty
  }
att.agentIdent.attributes = att.agentIdent.attribute.agent
att.agentIdent.attribute.agent =
  
  ## Signifies the causative agent of damage, illegibility, or other loss of original text.
  attribute agent { xsd:string }?
att.cpMark.log.attributes =
  att.controlEvent.attributes,
  att.origin.timestamp.logical.attributes,
  att.origin.staffIdent.attributes,
  att.origin.layerIdent.attributes,
  att.origin.startEndId.attributes,
  att.octaveDisplacement.attributes,
  att.startEndId.attributes,
  att.timestamp2.logical.attributes
att.edit.attributes = att.source.attributes, att.evidence.attributes
att.reasonIdent.attributes = att.reasonIdent.attribute.reason
att.reasonIdent.attribute.reason =
  
  ## Holds a short phrase describing the reason for missing textual material (gap), why material is supplied (supplied), or why transcription is difficult (unclear).
  attribute reason { xsd:string }?
att.trans.attributes =
  att.handIdent.attributes,
  att.metadataPointing.attributes,
  att.sequence.attributes
model.choicePart = model.editorialLike | model.editLike | sic
model.editLike = choice | subst
model.editTransPart =
  model.sylLike | model.editTransPart.music | model.editTransPart.text
model.editTransPart.music =
  model.controlEventLike
  | model.layerLike
  | model.controlEventLike.cmn
  | model.verseLike
model.editTransPart.text =
  model.textComponentLike | model.textPhraseLike.limited
model.transcriptionLike =
  add | damage | del | gap | restore | sic | supplied
abbr =
  
  ## (abbreviation)  A generic element for 1) a shortened form of a word, including an acronym or 2) a shorthand notation.
  element abbr {
    (text
     | model.divLike
     | model.editLike
     | model.editTransPart
     | model.layerPart
     | model.milestoneLike.music
     | model.sectionPart
     | model.staffGrpLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.edit.attributes,
    att.lang.attributes,
    att.trans.attributes,
    
    ## Records the expansion of a text abbreviation.
    attribute expan { xsd:string }?,
    empty
  }
add =
  
  ## (addition)  Marks an addition to the text.
  element add {
    (text
     | model.divLike
     | model.editLike
     | model.editTransPart
     | model.keyAccidLike
     | model.layerPart
     | model.milestoneLike.music
     | model.sectionPart
     | model.staffGrpLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.edit.attributes,
    att.extent.attributes,
    att.lang.attributes,
    att.trans.attributes,
    
    ## Location of the addition.
    attribute place {
      list { data.PLACEMENT+ }
    }?,
    empty
  }
choice =
  
  ## Groups a number of alternative encodings for the same point in a text.
  element choice { model.choicePart*, att.common.attributes, empty }
cpMark =
  
  ## (copy/colla parte mark)  A verbal or graphical indication to copy musical material written elsewhere.
  element cpMark {
    ((text
      | model.textPhraseLike.limited
      | model.editLike
      | model.transcriptionLike)*)
    >> sch:pattern [
         id =
           "wegaWorks-cpMark-cpMark_start-_and_end-type_attributes_required-constraint-rule-94"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:cpMark"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@dur or @dur.ges or @endid or @tstamp2"
             "Must have one of the attributes:\x{a}" ~
             "            dur, dur.ges, endid, or tstamp2"
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.common.attributes,
    att.cpMark.log.attributes,
    empty
  }
damage =
  
  ## Contains an area of damage to the physical medium.
  element damage {
    (text
     | model.divLike
     | model.editLike
     | model.editTransPart
     | model.keyAccidLike
     | model.layerPart
     | model.milestoneLike.music
     | model.sectionPart
     | model.staffGrpLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.agentIdent.attributes,
    att.extent.attributes,
    att.handIdent.attributes,
    att.lang.attributes,
    
    ## Records the degree of damage.
    attribute degree { xsd:string }?,
    empty
  }
del =
  
  ## (deletion)  Contains information deleted, marked as deleted, or otherwise indicated as superfluous or spurious in the copy text by an author, scribe, annotator, or corrector.
  element del {
    (text
     | model.divLike
     | model.editLike
     | model.editTransPart
     | model.keyAccidLike
     | model.layerPart
     | model.milestoneLike.music
     | model.sectionPart
     | model.staffGrpLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.edit.attributes,
    att.extent.attributes,
    att.lang.attributes,
    att.textRendition.attributes,
    att.trans.attributes,
    empty
  }
expan =
  
  ## (expansion)  Contains the expansion of an abbreviation.
  element expan {
    (text
     | model.divLike
     | model.editLike
     | model.editTransPart
     | model.layerPart
     | model.milestoneLike.music
     | model.sectionPart
     | model.staffGrpLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.edit.attributes,
    att.extent.attributes,
    att.lang.attributes,
    att.trans.attributes,
    
    ## Captures the abbreviated form of the text.
    attribute abbr { xsd:string }?,
    empty
  }
gap =
  
  ## Indicates a point where material has been omitted in a transcription, whether as part of sampling practice or for editorial reasons described in the MEI header.
  element gap {
    empty,
    att.common.attributes,
    att.edit.attributes,
    att.extent.attributes,
    att.handIdent.attributes,
    att.reasonIdent.attributes,
    empty
  }
restore =
  
  ## Indicates restoration of material to an earlier state by cancellation of an editorial or authorial marking or instruction.
  element restore {
    (text
     | model.divLike
     | model.editLike
     | model.editTransPart
     | model.keyAccidLike
     | model.layerPart
     | model.milestoneLike.music
     | model.sectionPart
     | model.staffGrpLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.edit.attributes,
    att.extent.attributes,
    att.lang.attributes,
    att.trans.attributes,
    
    ## Provides a description of the means of restoration, 'stet' or 'strike-down', for example.
    attribute desc { xsd:string }?,
    empty
  }
sic =
  
  ## Contains apparently incorrect or inaccurate material.
  element sic {
    (text
     | model.divLike
     | model.editLike
     | model.editTransPart
     | model.keyAccidLike
     | model.layerPart
     | model.milestoneLike.music
     | model.sectionPart
     | model.staffGrpLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.edit.attributes,
    att.extent.attributes,
    att.lang.attributes,
    empty
  }
subst =
  
  ## (substitution)  Groups transcriptional elements when the combination is to be regarded as a single intervention in the text.
  element subst {
    model.transcriptionLike,
    model.transcriptionLike+,
    att.common.attributes,
    att.edit.attributes,
    att.trans.attributes,
    empty
  }
supplied =
  
  ## Contains material supplied by the transcriber or editor for any reason.
  element supplied {
    (text
     | model.divLike
     | model.editLike
     | model.editTransPart
     | model.keyAccidLike
     | model.layerPart
     | model.milestoneLike.music
     | model.sectionPart
     | model.staffGrpLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.agentIdent.attributes,
    att.edit.attributes,
    att.extent.attributes,
    att.lang.attributes,
    att.reasonIdent.attributes,
    empty
  }
start = mei | work | source | expression
